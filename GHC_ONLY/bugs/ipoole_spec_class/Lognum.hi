{-# GHC_PRAGMA INTERFACE VERSION 5 #-}
interface Lognum where
data Lognum   = LN Double
mylog :: Int -> Double -> Double
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "LU(P)" {_A_ 2 _U_ 12 _N_ _N_ _N_ _N_} _N_ _N_ #-}
toLognum :: Real a => a -> Lognum
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _S_ "U(AAS)L" {_A_ 2 _U_ 12 _N_ _N_ _N_ _N_} _F_ _IF_ARGS_ 1 2 CX 6 _/\_ u0 -> \ (u1 :: {{Real u0}}) (u2 :: u0) -> let {(u6 :: Ratio Integer) = case u1 of { _ALG_ _TUP_3 (u3 :: {{Num u0}}) (u4 :: {{Enum u0}}) (u5 :: u0 -> Ratio Integer) -> _APP_  u5 [ u2 ]; _NO_DEFLT_ }} in _APP_  _CONSTM_ Fractional fromRational (Lognum) [ u6 ] _N_ #-}
instance Enum Lognum
	{-# GHC_PRAGMA _M_ Lognum {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 6 _!_ _TUP_5 [{{Ord Lognum}}, (Lognum -> [Lognum]), (Lognum -> Lognum -> [Lognum]), (Lognum -> Lognum -> [Lognum]), (Lognum -> Lognum -> Lognum -> [Lognum])] [_DFUN_ Ord (Lognum), _CONSTM_ Enum enumFrom (Lognum), _CONSTM_ Enum enumFromThen (Lognum), _CONSTM_ Enum enumFromTo (Lognum), _CONSTM_ Enum enumFromThenTo (Lognum)] _N_
	 enumFrom = _A_ 1 _U_ 2 _N_ _N_ _N_ _N_,
	 enumFromThen = _A_ 2 _U_ 21 _N_ _N_ _N_ _N_,
	 enumFromTo = _A_ 2 _U_ 22 _N_ _N_ _N_ _N_,
	 enumFromThenTo = _A_ 3 _U_ 222 _N_ _N_ _N_ _N_ #-}
instance Eq Lognum
	{-# GHC_PRAGMA _M_ Lognum {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Lognum -> Lognum -> Bool), (Lognum -> Lognum -> Bool)] [_CONSTM_ Eq (==) (Lognum), _CONSTM_ Eq (/=) (Lognum)] _N_
	 (==) = _A_ 2 _U_ 11 _N_ _S_ "U(U(P))U(U(P))" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 1 \ (u0 :: Double#) (u1 :: Double#) -> _#_ eqDouble# [] [u0, u1] _N_} _F_ _IF_ARGS_ 0 2 CC 5 \ (u0 :: Lognum) (u1 :: Lognum) -> case u0 of { _ALG_ _ORIG_ Lognum LN (u2 :: Double) -> case u1 of { _ALG_ _ORIG_ Lognum LN (u3 :: Double) -> case u2 of { _ALG_ D# (u4 :: Double#) -> case u3 of { _ALG_ D# (u5 :: Double#) -> _#_ eqDouble# [] [u4, u5]; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_,
	 (/=) = _A_ 2 _U_ 22 _N_ _N_ _N_ _N_ #-}
instance Floating Lognum
	{-# GHC_PRAGMA _M_ Lognum {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 20 _!_ _TUP_19 [{{Fractional Lognum}}, Lognum, (Lognum -> Lognum), (Lognum -> Lognum), (Lognum -> Lognum), (Lognum -> Lognum -> Lognum), (Lognum -> Lognum -> Lognum), (Lognum -> Lognum), (Lognum -> Lognum), (Lognum -> Lognum), (Lognum -> Lognum), (Lognum -> Lognum), (Lognum -> Lognum), (Lognum -> Lognum), (Lognum -> Lognum), (Lognum -> Lognum), (Lognum -> Lognum), (Lognum -> Lognum), (Lognum -> Lognum)] [_DFUN_ Fractional (Lognum), _CONSTM_ Floating pi (Lognum), _CONSTM_ Floating exp (Lognum), _CONSTM_ Floating log (Lognum), _CONSTM_ Floating sqrt (Lognum), _CONSTM_ Floating (**) (Lognum), _CONSTM_ Floating logBase (Lognum), _CONSTM_ Floating sin (Lognum), _CONSTM_ Floating cos (Lognum), _CONSTM_ Floating tan (Lognum), _CONSTM_ Floating asin (Lognum), _CONSTM_ Floating acos (Lognum), _CONSTM_ Floating atan (Lognum), _CONSTM_ Floating sinh (Lognum), _CONSTM_ Floating cosh (Lognum), _CONSTM_ Floating tanh (Lognum), _CONSTM_ Floating asinh (Lognum), _CONSTM_ Floating acosh (Lognum), _CONSTM_ Floating atanh (Lognum)] _N_
	 pi = _A_ 0 _N_ _N_ _N_ _N_ _N_,
	 exp = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Lognum) -> _APP_  _TYAPP_  patError# { (Lognum -> Lognum) } [ _NOREP_S_ "%DPreludeCore.Floating.exp\"", u0 ] _N_,
	 log = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Lognum) -> _APP_  _TYAPP_  patError# { (Lognum -> Lognum) } [ _NOREP_S_ "%DPreludeCore.Floating.log\"", u0 ] _N_,
	 sqrt = _A_ 1 _U_ 1 _N_ _S_ "U(L)" {_A_ 1 _U_ 1 _N_ _N_ _N_ _N_} _N_ _N_,
	 (**) = _A_ 2 _U_ 11 _N_ _S_ "U(L)U(L)" {_A_ 2 _U_ 11 _N_ _N_ _N_ _N_} _N_ _N_,
	 logBase = _A_ 2 _U_ 22 _N_ _N_ _N_ _N_,
	 sin = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Lognum) -> _APP_  _TYAPP_  patError# { (Lognum -> Lognum) } [ _NOREP_S_ "%DPreludeCore.Floating.sin\"", u0 ] _N_,
	 cos = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Lognum) -> _APP_  _TYAPP_  patError# { (Lognum -> Lognum) } [ _NOREP_S_ "%DPreludeCore.Floating.cos\"", u0 ] _N_,
	 tan = _A_ 1 _U_ 2 _N_ _N_ _N_ _N_,
	 asin = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Lognum) -> _APP_  _TYAPP_  patError# { (Lognum -> Lognum) } [ _NOREP_S_ "%DPreludeCore.Floating.asin\"", u0 ] _N_,
	 acos = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Lognum) -> _APP_  _TYAPP_  patError# { (Lognum -> Lognum) } [ _NOREP_S_ "%DPreludeCore.Floating.acos\"", u0 ] _N_,
	 atan = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Lognum) -> _APP_  _TYAPP_  patError# { (Lognum -> Lognum) } [ _NOREP_S_ "%DPreludeCore.Floating.atan\"", u0 ] _N_,
	 sinh = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Lognum) -> _APP_  _TYAPP_  patError# { (Lognum -> Lognum) } [ _NOREP_S_ "%DPreludeCore.Floating.sinh\"", u0 ] _N_,
	 cosh = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Lognum) -> _APP_  _TYAPP_  patError# { (Lognum -> Lognum) } [ _NOREP_S_ "%DPreludeCore.Floating.cosh\"", u0 ] _N_,
	 tanh = _A_ 1 _U_ 2 _N_ _N_ _N_ _N_,
	 asinh = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Lognum) -> _APP_  _TYAPP_  patError# { (Lognum -> Lognum) } [ _NOREP_S_ "%DPreludeCore.Floating.asinh\"", u0 ] _N_,
	 acosh = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Lognum) -> _APP_  _TYAPP_  patError# { (Lognum -> Lognum) } [ _NOREP_S_ "%DPreludeCore.Floating.acosh\"", u0 ] _N_,
	 atanh = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Lognum) -> _APP_  _TYAPP_  patError# { (Lognum -> Lognum) } [ _NOREP_S_ "%DPreludeCore.Floating.atanh\"", u0 ] _N_ #-}
instance Fractional Lognum
	{-# GHC_PRAGMA _M_ Lognum {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 5 _!_ _TUP_4 [{{Num Lognum}}, (Lognum -> Lognum -> Lognum), (Lognum -> Lognum), (Ratio Integer -> Lognum)] [_DFUN_ Num (Lognum), _CONSTM_ Fractional (/) (Lognum), _CONSTM_ Fractional recip (Lognum), _CONSTM_ Fractional fromRational (Lognum)] _N_
	 (/) = _A_ 2 _U_ 11 _N_ _S_ "U(L)U(L)" {_A_ 2 _U_ 11 _N_ _N_ _N_ _N_} _N_ _N_,
	 recip = _A_ 0 _U_ 2 _N_ _N_ _N_ _N_,
	 fromRational = _A_ 1 _U_ 1 _N_ _S_ "U(U(PPP)L)" {_A_ 4 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
instance Num Lognum
	{-# GHC_PRAGMA _M_ Lognum {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 11 _!_ _TUP_10 [{{Eq Lognum}}, {{Text Lognum}}, (Lognum -> Lognum -> Lognum), (Lognum -> Lognum -> Lognum), (Lognum -> Lognum -> Lognum), (Lognum -> Lognum), (Lognum -> Lognum), (Lognum -> Lognum), (Integer -> Lognum), (Int -> Lognum)] [_DFUN_ Eq (Lognum), _DFUN_ Text (Lognum), _CONSTM_ Num (+) (Lognum), _CONSTM_ Num (-) (Lognum), _CONSTM_ Num (*) (Lognum), _CONSTM_ Num negate (Lognum), _CONSTM_ Num abs (Lognum), _CONSTM_ Num signum (Lognum), _CONSTM_ Num fromInteger (Lognum), _CONSTM_ Num fromInt (Lognum)] _N_
	 (+) = _A_ 2 _U_ 11 _N_ _S_ "U(L)U(L)" {_A_ 2 _U_ 11 _N_ _N_ _N_ _N_} _N_ _N_,
	 (-) = _A_ 2 _U_ 11 _N_ _S_ "U(U(P))U(U(P))" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_,
	 (*) = _A_ 2 _U_ 11 _N_ _S_ "U(L)U(L)" {_A_ 2 _U_ 11 _N_ _N_ _N_ _N_} _N_ _N_,
	 negate = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Lognum) -> _APP_  _TYAPP_  patError# { (Lognum -> Lognum) } [ _NOREP_S_ "%DPreludeCore.Num.negate\"", u0 ] _N_,
	 abs = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Lognum) -> _APP_  _TYAPP_  patError# { (Lognum -> Lognum) } [ _NOREP_S_ "%DPreludeCore.Num.abs\"", u0 ] _N_,
	 signum = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Lognum) -> _APP_  _TYAPP_  patError# { (Lognum -> Lognum) } [ _NOREP_S_ "%DPreludeCore.Num.signum\"", u0 ] _N_,
	 fromInteger = _A_ 1 _U_ 1 _N_ _S_ "U(PPP)" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_,
	 fromInt = _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _F_ _IF_ARGS_ 0 1 C 5 \ (u0 :: Int) -> let {(u2 :: Integer) = case u0 of { _ALG_ I# (u1 :: Int#) -> _#_ int2Integer# [] [u1]; _NO_DEFLT_ }} in _APP_  _CONSTM_ Num fromInteger (Lognum) [ u2 ] _N_ #-}
instance Ord Lognum
	{-# GHC_PRAGMA _M_ Lognum {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 9 _!_ _TUP_8 [{{Eq Lognum}}, (Lognum -> Lognum -> Bool), (Lognum -> Lognum -> Bool), (Lognum -> Lognum -> Bool), (Lognum -> Lognum -> Bool), (Lognum -> Lognum -> Lognum), (Lognum -> Lognum -> Lognum), (Lognum -> Lognum -> _CMP_TAG)] [_DFUN_ Eq (Lognum), _CONSTM_ Ord (<) (Lognum), _CONSTM_ Ord (<=) (Lognum), _CONSTM_ Ord (>=) (Lognum), _CONSTM_ Ord (>) (Lognum), _CONSTM_ Ord max (Lognum), _CONSTM_ Ord min (Lognum), _CONSTM_ Ord _tagCmp (Lognum)] _N_
	 (<) = _A_ 2 _U_ 22 _N_ _N_ _N_ _N_,
	 (<=) = _A_ 2 _U_ 11 _N_ _S_ "U(U(P))U(U(P))" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 5 \ (u0 :: Double#) (u1 :: Double#) -> case _#_ gtDouble# [] [u0, u1] of { _ALG_ True  -> _!_ False [] []; False  -> _!_ True [] []; _NO_DEFLT_ } _N_} _F_ _ALWAYS_ \ (u0 :: Lognum) (u1 :: Lognum) -> case u0 of { _ALG_ _ORIG_ Lognum LN (u2 :: Double) -> case u2 of { _ALG_ D# (u3 :: Double#) -> case u1 of { _ALG_ _ORIG_ Lognum LN (u4 :: Double) -> case u4 of { _ALG_ D# (u5 :: Double#) -> case _#_ gtDouble# [] [u3, u5] of { _ALG_ True  -> _!_ False [] []; False  -> _!_ True [] []; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_,
	 (>=) = _A_ 2 _U_ 11 _N_ _S_ "U(U(P))U(U(P))" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 5 \ (u0 :: Double#) (u1 :: Double#) -> case _#_ gtDouble# [] [u1, u0] of { _ALG_ True  -> _!_ False [] []; False  -> _!_ True [] []; _NO_DEFLT_ } _N_} _F_ _IF_ARGS_ 0 2 XX 3 \ (u0 :: Lognum) (u1 :: Lognum) -> _APP_  _CONSTM_ Ord (<=) (Lognum) [ u1, u0 ] _N_,
	 (>) = _A_ 2 _U_ 11 _N_ _S_ "U(U(P))U(U(P))" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 1 \ (u0 :: Double#) (u1 :: Double#) -> _#_ gtDouble# [] [u0, u1] _N_} _F_ _IF_ARGS_ 0 2 CC 5 \ (u0 :: Lognum) (u1 :: Lognum) -> case u0 of { _ALG_ _ORIG_ Lognum LN (u2 :: Double) -> case u1 of { _ALG_ _ORIG_ Lognum LN (u3 :: Double) -> case u2 of { _ALG_ D# (u4 :: Double#) -> case u3 of { _ALG_ D# (u5 :: Double#) -> _#_ gtDouble# [] [u4, u5]; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_,
	 max = _A_ 2 _U_ 22 _N_ _N_ _N_ _N_,
	 min = _A_ 2 _U_ 22 _N_ _N_ _N_ _N_,
	 _tagCmp = _A_ 2 _U_ 22 _N_ _N_ _N_ _N_ #-}
instance Real Lognum
	{-# GHC_PRAGMA _M_ Lognum {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 4 _!_ _TUP_3 [{{Num Lognum}}, {{Enum Lognum}}, (Lognum -> Ratio Integer)] [_DFUN_ Num (Lognum), _DFUN_ Enum (Lognum), _CONSTM_ Real toRational (Lognum)] _N_
	 toRational = _A_ 1 _U_ 1 _N_ _S_ "U(U(P))" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Double#) -> case _#_ expDouble# [] [u0] of { _PRIM_ (u1 :: Double#) -> _APP_  _WRKR_ _CONSTM_ Real toRational (Double) [ u1 ] } _N_} _F_ _IF_ARGS_ 0 1 C 5 \ (u0 :: Lognum) -> case u0 of { _ALG_ _ORIG_ Lognum LN (u1 :: Double) -> case u1 of { _ALG_ D# (u2 :: Double#) -> case _#_ expDouble# [] [u2] of { _PRIM_ (u3 :: Double#) -> _APP_  _WRKR_ _CONSTM_ Real toRational (Double) [ u3 ] }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ #-}
instance RealFloat Lognum
	{-# GHC_PRAGMA _M_ Lognum {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 11 _!_ _TUP_10 [{{RealFrac Lognum}}, {{Floating Lognum}}, (Lognum -> Integer), (Lognum -> Int), (Lognum -> (Int, Int)), (Lognum -> (Integer, Int)), (Integer -> Int -> Lognum), (Lognum -> Int), (Lognum -> Lognum), (Int -> Lognum -> Lognum)] [_DFUN_ RealFrac (Lognum), _DFUN_ Floating (Lognum), _CONSTM_ RealFloat floatRadix (Lognum), _CONSTM_ RealFloat floatDigits (Lognum), _CONSTM_ RealFloat floatRange (Lognum), _CONSTM_ RealFloat decodeFloat (Lognum), _CONSTM_ RealFloat encodeFloat (Lognum), _CONSTM_ RealFloat exponent (Lognum), _CONSTM_ RealFloat significand (Lognum), _CONSTM_ RealFloat scaleFloat (Lognum)] _N_
	 floatRadix = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Lognum) -> _APP_  _TYAPP_  patError# { (Lognum -> Integer) } [ _NOREP_S_ "%DPreludeCore.RealFloat.floatRadix\"", u0 ] _N_,
	 floatDigits = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Lognum) -> _APP_  _TYAPP_  patError# { (Lognum -> Int) } [ _NOREP_S_ "%DPreludeCore.RealFloat.floatDigits\"", u0 ] _N_,
	 floatRange = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Lognum) -> _APP_  _TYAPP_  patError# { (Lognum -> (Int, Int)) } [ _NOREP_S_ "%DPreludeCore.RealFloat.floatRange\"", u0 ] _N_,
	 decodeFloat = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Lognum) -> _APP_  _TYAPP_  patError# { (Lognum -> (Integer, Int)) } [ _NOREP_S_ "%DPreludeCore.RealFloat.decodeFloat\"", u0 ] _N_,
	 encodeFloat = _A_ 2 _U_ 22 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 2 XX 4 \ (u0 :: Integer) (u1 :: Int) -> _APP_  _TYAPP_  patError# { (Integer -> Int -> Lognum) } [ _NOREP_S_ "%DPreludeCore.RealFloat.encodeFloat\"", u0, u1 ] _N_,
	 exponent = _A_ 1 _U_ 2 _N_ _N_ _N_ _N_,
	 significand = _A_ 1 _U_ 2 _N_ _N_ _N_ _N_,
	 scaleFloat = _A_ 2 _U_ 22 _N_ _N_ _N_ _N_ #-}
instance RealFrac Lognum
	{-# GHC_PRAGMA _M_ Lognum {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 8 _!_ _TUP_7 [{{Real Lognum}}, {{Fractional Lognum}}, _forall_ a$z1 =>{{Integral a$z1}} -> (Lognum -> (a$z1, Lognum)), _forall_ a$z1 =>{{Integral a$z1}} -> (Lognum -> a$z1), _forall_ a$z1 =>{{Integral a$z1}} -> (Lognum -> a$z1), _forall_ a$z1 =>{{Integral a$z1}} -> (Lognum -> a$z1), _forall_ a$z1 =>{{Integral a$z1}} -> (Lognum -> a$z1)] [_DFUN_ Real (Lognum), _DFUN_ Fractional (Lognum), _CONSTM_ RealFrac properFraction (Lognum), _CONSTM_ RealFrac truncate (Lognum), _CONSTM_ RealFrac round (Lognum), _CONSTM_ RealFrac ceiling (Lognum), _CONSTM_ RealFrac floor (Lognum)] _N_
	 properFraction = _A_ 2 _U_ 02 _N_ _S_ _!_ _F_ _IF_ARGS_ 1 2 XX 3 _/\_ u0 -> \ (u1 :: {{Integral u0}}) (u2 :: Lognum) -> _APP_  _TYAPP_  patError# { (Lognum -> (u0, Lognum)) } [ _NOREP_S_ "%DPreludeCore.RealFrac.properFraction\"", u2 ] _N_,
	 truncate = _A_ 1 _U_ 22 _N_ _N_ _N_ _N_,
	 round = _A_ 1 _U_ 22 _N_ _N_ _N_ _N_,
	 ceiling = _A_ 1 _U_ 22 _N_ _N_ _N_ _N_,
	 floor = _A_ 1 _U_ 22 _N_ _N_ _N_ _N_ #-}
instance Text Lognum
	{-# GHC_PRAGMA _M_ Lognum {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 5 _!_ _TUP_4 [(Int -> [Char] -> [(Lognum, [Char])]), (Int -> Lognum -> [Char] -> [Char]), ([Char] -> [([Lognum], [Char])]), ([Lognum] -> [Char] -> [Char])] [_CONSTM_ Text readsPrec (Lognum), _CONSTM_ Text showsPrec (Lognum), _CONSTM_ Text readList (Lognum), _CONSTM_ Text showList (Lognum)] _N_
	 readsPrec = _A_ 2 _U_ 22 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 2 XX 4 \ (u0 :: Int) (u1 :: [Char]) -> _APP_  _TYAPP_  patError# { (Int -> [Char] -> [(Lognum, [Char])]) } [ _NOREP_S_ "%DPreludeCore.Text.readsPrec\"", u0, u1 ] _N_,
	 showsPrec = _A_ 3 _U_ 222 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 3 XXX 5 \ (u0 :: Int) (u1 :: Lognum) (u2 :: [Char]) -> _APP_  _TYAPP_  patError# { (Int -> Lognum -> [Char] -> [Char]) } [ _NOREP_S_ "%DPreludeCore.Text.showsPrec\"", u0, u1, u2 ] _N_,
	 readList = _A_ 0 _U_ 2 _N_ _N_ _N_ _N_,
	 showList = _A_ 0 _U_ 12 _N_ _N_ _N_ _N_ #-}

