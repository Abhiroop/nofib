{-# GHC_PRAGMA INTERFACE VERSION 5 #-}
interface GenUtils where
import PreludeArray(Assoc)
data Maybe a   = Nothing | Just a
data MaybeErr a b   = Succeeded a | Failed b
arrCond :: Ix a => (a, a) -> [Assoc [a] b] -> [Assoc (a -> Bool) b] -> b -> a -> b
	{-# GHC_PRAGMA _A_ 5 _U_ 122222 _N_ _S_ "U(LSSA)U(LL)LLL" _N_ _N_ #-}
arrElem :: Ix a => [a] -> a -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 122 _N_ _S_ "U(LLLS)" {_A_ 4 _U_ 222122 _N_ _N_ _N_ _N_} _N_ _N_ #-}
assocMaybe :: Eq a => [(a, b)] -> a -> Maybe b
	{-# GHC_PRAGMA _A_ 3 _U_ 112 _N_ _S_ "LSL" _N_ _N_ #-}
assocMaybeErr :: Eq a => [(a, b)] -> a -> MaybeErr b [Char]
	{-# GHC_PRAGMA _A_ 3 _U_ 112 _N_ _S_ "LSL" _N_ _N_ #-}
cjustify :: Int -> [Char] -> [Char]
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _S_ "U(P)S" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
combinePairs :: Ord a => [(a, b)] -> [(a, [b])]
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _S_ "LS" _N_ _N_ #-}
copy :: Int -> a -> [a]
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _S_ "U(P)L" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
foldb :: (a -> a -> a) -> [a] -> a
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _S_ "LS" _N_ _N_ #-}
formatText :: Int -> [[Char]] -> [[Char]]
	{-# GHC_PRAGMA _A_ 1 _U_ 22 _N_ _N_ _N_ _N_ #-}
joinMaybe :: (a -> a -> a) -> Maybe a -> Maybe a -> Maybe a
	{-# GHC_PRAGMA _A_ 3 _U_ 111 _N_ _S_ "LSS" _N_ _N_ #-}
ljustify :: Int -> [Char] -> [Char]
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _S_ "LS" _N_ _N_ #-}
mapAccumL :: (c -> a -> (b, c)) -> c -> [a] -> ([b], c)
	{-# GHC_PRAGMA _A_ 3 _U_ 221 _N_ _N_ _N_ _N_ #-}
mapMaybe :: (a -> Maybe b) -> [a] -> [b]
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ #-}
mapMaybeFail :: (a -> Maybe b) -> [a] -> Maybe [b]
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ #-}
maybeMap :: (a -> b) -> Maybe a -> Maybe b
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "LS" _N_ _N_ #-}
maybeToBool :: Maybe a -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _IF_ARGS_ 1 1 C 4 _/\_ u0 -> \ (u1 :: Maybe u0) -> case u1 of { _ALG_ _ORIG_ GenUtils Nothing  -> _!_ False [] []; _ORIG_ GenUtils Just (u2 :: u0) -> _!_ True [] []; _NO_DEFLT_ } _N_ #-}
maybeToObj :: Maybe a -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _IF_ARGS_ 1 1 C 5 _/\_ u0 -> \ (u1 :: Maybe u0) -> case u1 of { _ALG_ _ORIG_ GenUtils Nothing  -> _APP_  _TYAPP_  error { u0 } [ _NOREP_S_ "Trying to extract object from a Nothing" ]; _ORIG_ GenUtils Just (u2 :: u0) -> u2; _NO_DEFLT_ } _N_ #-}
memoise :: Ix a => (a, a) -> (a -> b) -> a -> b
	{-# GHC_PRAGMA _A_ 3 _U_ 1122 _N_ _S_ "U(ASSA)U(LL)L" {_A_ 5 _U_ 222222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
mkClosure :: (a -> a -> Bool) -> (a -> a) -> a -> a
	{-# GHC_PRAGMA _A_ 3 _U_ 222 _N_ _N_ _N_ _N_ #-}
rjustify :: Int -> [Char] -> [Char]
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _S_ "U(P)S" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
sort :: Ord a => [a] -> [a]
	{-# GHC_PRAGMA _A_ 1 _U_ 12 _N_ _N_ _F_ _IF_ARGS_ 1 1 C 5 _/\_ u0 -> \ (u1 :: {{Ord u0}}) -> let {(ua :: u0 -> u0 -> Bool) = case u1 of { _ALG_ _TUP_8 (u2 :: {{Eq u0}}) (u3 :: u0 -> u0 -> Bool) (u4 :: u0 -> u0 -> Bool) (u5 :: u0 -> u0 -> Bool) (u6 :: u0 -> u0 -> Bool) (u7 :: u0 -> u0 -> u0) (u8 :: u0 -> u0 -> u0) (u9 :: u0 -> u0 -> _CMP_TAG) -> u4; _NO_DEFLT_ }} in _APP_  _TYAPP_  _ORIG_ GenUtils sortWith { u0 } [ ua ] _N_ #-}
sortWith :: (a -> a -> Bool) -> [a] -> [a]
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _S_ "LS" _N_ _N_ #-}
space :: Int -> [Char]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ #-}
instance Eq a => Eq (Maybe a)
	{-# GHC_PRAGMA _M_ GenUtils {-dfun-} _A_ 1 _U_ 1 _N_ _N_ _N_ _N_ #-}
instance (Eq a, Eq b) => Eq (MaybeErr a b)
	{-# GHC_PRAGMA _M_ GenUtils {-dfun-} _A_ 2 _U_ 11 _N_ _N_ _N_ _N_ #-}
instance Ord a => Ord (Maybe a)
	{-# GHC_PRAGMA _M_ GenUtils {-dfun-} _A_ 2 _U_ 22 _N_ _N_ _N_ _N_ #-}
instance Text a => Text (Maybe a)
	{-# GHC_PRAGMA _M_ GenUtils {-dfun-} _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ #-}
instance (Text a, Text b) => Text (MaybeErr a b)
	{-# GHC_PRAGMA _M_ GenUtils {-dfun-} _A_ 2 _U_ 22 _N_ _N_ _N_ _N_ #-}

