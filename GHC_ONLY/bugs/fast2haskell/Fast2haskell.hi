{-# GHC_PRAGMA INTERFACE VERSION 5 #-}
interface Fast2haskell where
import PreludeArray(Array, Assoc)
import PreludeComplex(Complex)
import PreludeIO(Request, Response)
type Array_type a = Array Int a
type Assoc_type a = Assoc Int a
type Complex_type = Complex Double
type Descr_type = (Int, Int)
abortstr :: [Char] -> [Response] -> [Request]
	{-# GHC_PRAGMA _A_ 2 _U_ 00 _N_ _S_ "AA" {_A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _!_ _NIL_ [Request] [] _N_} _F_ _IF_ARGS_ 0 2 XX 1 \ (u0 :: [Char]) (u1 :: [Response]) -> _!_ _NIL_ [Request] [] _N_ #-}
delay :: a -> [Response] -> [Request]
	{-# GHC_PRAGMA _A_ 2 _U_ 00 _N_ _S_ "A" {_A_ 1 _U_ 0 _N_ _N_ _F_ _IF_ARGS_ 1 1 X 1 _/\_ u0 -> \ (u1 :: [Response]) -> _!_ _NIL_ [Request] [] _N_} _F_ _IF_ARGS_ 1 1 X 2 _/\_ u0 -> \ (u1 :: u0) -> _APP_  _ORIG_ Fast2haskell abortstr [ _NOREP_S_ "delay not implemented" ] _N_ #-}
descr :: a -> b -> (a, b)
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 2 2 XX 3 _/\_ u0 u1 -> \ (u2 :: u0) (u3 :: u1) -> _!_ _TUP_2 [u0, u1] [u2, u3] _N_ #-}
destr_update :: Ix a => Array a b -> a -> b -> Array a b
	{-# GHC_PRAGMA _A_ 1 _U_ 1222 _N_ _S_ "U(ASLA)" {_A_ 2 _U_ 22222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
entier :: (Num b, RealFrac a) => a -> b
	{-# GHC_PRAGMA _A_ 2 _U_ 112 _N_ _S_ "U(AAAAAAAASA)L" {_A_ 2 _U_ 112 _N_ _N_ _N_ _N_} _N_ _N_ #-}
fix :: (a -> a) -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _S_ "S" _F_ _IF_ARGS_ 1 1 X 4 _/\_ u0 -> \ (u1 :: u0 -> u0) -> _LETREC_ {(u2 :: u0) = _APP_  u1 [ u2 ]} in u2 _N_ #-}
force :: a -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _IF_ARGS_ 1 1 X 1 _/\_ u0 -> \ (u1 :: u0) -> u1 _N_ #-}
iff :: Bool -> a -> a -> a
	{-# GHC_PRAGMA _A_ 3 _U_ 111 _N_ _S_ "ELL" _F_ _IF_ARGS_ 1 3 CXX 4 _/\_ u0 -> \ (u1 :: Bool) (u2 :: u0) (u3 :: u0) -> case u1 of { _ALG_ True  -> u2; False  -> u3; _NO_DEFLT_ } _N_ #-}
iffrev :: a -> a -> Bool -> a
	{-# GHC_PRAGMA _A_ 3 _U_ 111 _N_ _S_ "LLE" _F_ _IF_ARGS_ 1 3 XXC 4 _/\_ u0 -> \ (u1 :: u0) (u2 :: u0) (u3 :: Bool) -> case u3 of { _ALG_ True  -> u2; False  -> u1; _NO_DEFLT_ } _N_ #-}
indassoc :: Assoc b a -> b
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(SA)" {_A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 2 1 X 1 _/\_ u0 u1 -> \ (u2 :: u1) -> u2 _N_} _F_ _IF_ARGS_ 2 1 C 2 _/\_ u0 u1 -> \ (u2 :: Assoc u1 u0) -> case u2 of { _ALG_ (:=) (u3 :: u1) (u4 :: u0) -> u3; _NO_DEFLT_ } _N_ #-}
land_i :: Int -> Int -> Int
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
lnot_i :: Int -> Int
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ #-}
lor_i :: Int -> Int -> Int
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
lowbound :: (b, a) -> b
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(SA)" {_A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 2 1 X 1 _/\_ u0 u1 -> \ (u2 :: u1) -> u2 _N_} _F_ _IF_ARGS_ 2 1 C 2 _/\_ u0 u1 -> \ (u2 :: (u1, u0)) -> case u2 of { _ALG_ _TUP_2 (u3 :: u1) (u4 :: u0) -> u3; _NO_DEFLT_ } _N_ #-}
lshift_i :: Int -> Int -> Int
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
pair :: [a] -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _IF_ARGS_ 1 1 C 4 _/\_ u0 -> \ (u1 :: [u0]) -> case u1 of { _ALG_ (:) (u2 :: u0) (u3 :: [u0]) -> _!_ True [] []; _NIL_  -> _!_ False [] []; _NO_DEFLT_ } _N_ #-}
rshift_i :: Int -> Int -> Int
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
seq :: a -> b -> b
	{-# GHC_PRAGMA _A_ 2 _U_ 01 _N_ _S_ "AS" {_A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 2 1 X 1 _/\_ u0 u1 -> \ (u2 :: u1) -> u2 _N_} _F_ _IF_ARGS_ 2 2 XX 1 _/\_ u0 u1 -> \ (u2 :: u0) (u3 :: u1) -> u3 _N_ #-}
strcmp :: [Char] -> [Char] -> Bool
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _CONSTM_ Eq (==) ([Char]) _N_ #-}
tabulate :: (Ix a, Enum a) => (a -> b) -> (a, a) -> Array a b
	{-# GHC_PRAGMA _A_ 4 _U_ 1122 _N_ _S_ "U(ASLA)LLU(LL)" {_A_ 5 _U_ 22122 _N_ _N_ _N_ _N_} _N_ _N_ #-}
upbound :: (a, b) -> b
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(AS)" {_A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 2 1 X 1 _/\_ u0 u1 -> \ (u2 :: u1) -> u2 _N_} _F_ _IF_ARGS_ 2 1 C 2 _/\_ u0 u1 -> \ (u2 :: (u0, u1)) -> case u2 of { _ALG_ _TUP_2 (u3 :: u0) (u4 :: u1) -> u4; _NO_DEFLT_ } _N_ #-}
update :: Ix a => Array a b -> a -> b -> Array a b
	{-# GHC_PRAGMA _A_ 1 _U_ 1222 _N_ _S_ "U(ASLA)" {_A_ 2 _U_ 22222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
valassoc :: Assoc a b -> b
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(AS)" {_A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 2 1 X 1 _/\_ u0 u1 -> \ (u2 :: u1) -> u2 _N_} _F_ _IF_ARGS_ 2 1 C 2 _/\_ u0 u1 -> \ (u2 :: Assoc u0 u1) -> case u2 of { _ALG_ (:=) (u3 :: u0) (u4 :: u1) -> u4; _NO_DEFLT_ } _N_ #-}

