{-# GHC_PRAGMA INTERFACE VERSION 5 #-}
interface Word2 where
infixl 7 `bitAnd`
infixl 8 `bitLsh`
infixl 5 `bitOr`
infixl 8 `bitRsh`
infixl 6 `bitXor`
class Bits a where
	bitAnd :: a -> a -> a
	 {-# GHC_PRAGMA {-meth-} _A_ 1 _U_ 122 _N_ _S_ "U(SAAAAAAAA)" {_A_ 1 _U_ 122 _N_ _N_ _F_ _IF_ARGS_ 1 1 X 1 _/\_ u0 -> \ (u1 :: u0 -> u0 -> u0) -> u1 _N_} _F_ _IF_ARGS_ 1 1 C 2 _/\_ u0 -> \ (u1 :: (u0 -> u0 -> u0, u0 -> u0 -> u0, u0 -> u0 -> u0, u0 -> u0, u0 -> Int -> u0, u0 -> Int -> u0, u0 -> u0, u0, u0 -> Int)) -> case u1 of { _ALG_ _TUP_9 (u2 :: u0 -> u0 -> u0) (u3 :: u0 -> u0 -> u0) (u4 :: u0 -> u0 -> u0) (u5 :: u0 -> u0) (u6 :: u0 -> Int -> u0) (u7 :: u0 -> Int -> u0) (u8 :: u0 -> u0) (u9 :: u0) (ua :: u0 -> Int) -> u2; _NO_DEFLT_ } _N_
		{-defm-} _A_ 3 _U_ 022 _N_ _S_ _!_ _F_ _IF_ARGS_ 1 3 XXX 4 _/\_ u0 -> \ (u1 :: {{Bits u0}}) (u2 :: u0) (u3 :: u0) -> _APP_  _TYAPP_  patError# { (u0 -> u0 -> u0) } [ _NOREP_S_ "%DWord2.Bits.bitAnd\"", u2, u3 ] _N_ #-}
	bitOr :: a -> a -> a
	 {-# GHC_PRAGMA {-meth-} _A_ 1 _U_ 122 _N_ _S_ "U(ASAAAAAAA)" {_A_ 1 _U_ 122 _N_ _N_ _F_ _IF_ARGS_ 1 1 X 1 _/\_ u0 -> \ (u1 :: u0 -> u0 -> u0) -> u1 _N_} _F_ _IF_ARGS_ 1 1 C 2 _/\_ u0 -> \ (u1 :: (u0 -> u0 -> u0, u0 -> u0 -> u0, u0 -> u0 -> u0, u0 -> u0, u0 -> Int -> u0, u0 -> Int -> u0, u0 -> u0, u0, u0 -> Int)) -> case u1 of { _ALG_ _TUP_9 (u2 :: u0 -> u0 -> u0) (u3 :: u0 -> u0 -> u0) (u4 :: u0 -> u0 -> u0) (u5 :: u0 -> u0) (u6 :: u0 -> Int -> u0) (u7 :: u0 -> Int -> u0) (u8 :: u0 -> u0) (u9 :: u0) (ua :: u0 -> Int) -> u3; _NO_DEFLT_ } _N_
		{-defm-} _A_ 3 _U_ 022 _N_ _S_ _!_ _F_ _IF_ARGS_ 1 3 XXX 4 _/\_ u0 -> \ (u1 :: {{Bits u0}}) (u2 :: u0) (u3 :: u0) -> _APP_  _TYAPP_  patError# { (u0 -> u0 -> u0) } [ _NOREP_S_ "%DWord2.Bits.bitOr\"", u2, u3 ] _N_ #-}
	bitXor :: a -> a -> a
	 {-# GHC_PRAGMA {-meth-} _A_ 1 _U_ 122 _N_ _S_ "U(AASAAAAAA)" {_A_ 1 _U_ 122 _N_ _N_ _F_ _IF_ARGS_ 1 1 X 1 _/\_ u0 -> \ (u1 :: u0 -> u0 -> u0) -> u1 _N_} _F_ _IF_ARGS_ 1 1 C 2 _/\_ u0 -> \ (u1 :: (u0 -> u0 -> u0, u0 -> u0 -> u0, u0 -> u0 -> u0, u0 -> u0, u0 -> Int -> u0, u0 -> Int -> u0, u0 -> u0, u0, u0 -> Int)) -> case u1 of { _ALG_ _TUP_9 (u2 :: u0 -> u0 -> u0) (u3 :: u0 -> u0 -> u0) (u4 :: u0 -> u0 -> u0) (u5 :: u0 -> u0) (u6 :: u0 -> Int -> u0) (u7 :: u0 -> Int -> u0) (u8 :: u0 -> u0) (u9 :: u0) (ua :: u0 -> Int) -> u4; _NO_DEFLT_ } _N_
		{-defm-} _A_ 3 _U_ 022 _N_ _S_ _!_ _F_ _IF_ARGS_ 1 3 XXX 4 _/\_ u0 -> \ (u1 :: {{Bits u0}}) (u2 :: u0) (u3 :: u0) -> _APP_  _TYAPP_  patError# { (u0 -> u0 -> u0) } [ _NOREP_S_ "%DWord2.Bits.bitXor\"", u2, u3 ] _N_ #-}
	bitCompl :: a -> a
	 {-# GHC_PRAGMA {-meth-} _A_ 1 _U_ 12 _N_ _S_ "U(AAASAAAAA)" {_A_ 1 _U_ 12 _N_ _N_ _F_ _IF_ARGS_ 1 1 X 1 _/\_ u0 -> \ (u1 :: u0 -> u0) -> u1 _N_} _F_ _IF_ARGS_ 1 1 C 2 _/\_ u0 -> \ (u1 :: (u0 -> u0 -> u0, u0 -> u0 -> u0, u0 -> u0 -> u0, u0 -> u0, u0 -> Int -> u0, u0 -> Int -> u0, u0 -> u0, u0, u0 -> Int)) -> case u1 of { _ALG_ _TUP_9 (u2 :: u0 -> u0 -> u0) (u3 :: u0 -> u0 -> u0) (u4 :: u0 -> u0 -> u0) (u5 :: u0 -> u0) (u6 :: u0 -> Int -> u0) (u7 :: u0 -> Int -> u0) (u8 :: u0 -> u0) (u9 :: u0) (ua :: u0 -> Int) -> u5; _NO_DEFLT_ } _N_
		{-defm-} _A_ 2 _U_ 02 _N_ _S_ _!_ _F_ _IF_ARGS_ 1 2 XX 3 _/\_ u0 -> \ (u1 :: {{Bits u0}}) (u2 :: u0) -> _APP_  _TYAPP_  patError# { (u0 -> u0) } [ _NOREP_S_ "%DWord2.Bits.bitCompl\"", u2 ] _N_ #-}
	bitRsh :: a -> Int -> a
	 {-# GHC_PRAGMA {-meth-} _A_ 1 _U_ 122 _N_ _S_ "U(AAAASAAAA)" {_A_ 1 _U_ 122 _N_ _N_ _F_ _IF_ARGS_ 1 1 X 1 _/\_ u0 -> \ (u1 :: u0 -> Int -> u0) -> u1 _N_} _F_ _IF_ARGS_ 1 1 C 2 _/\_ u0 -> \ (u1 :: (u0 -> u0 -> u0, u0 -> u0 -> u0, u0 -> u0 -> u0, u0 -> u0, u0 -> Int -> u0, u0 -> Int -> u0, u0 -> u0, u0, u0 -> Int)) -> case u1 of { _ALG_ _TUP_9 (u2 :: u0 -> u0 -> u0) (u3 :: u0 -> u0 -> u0) (u4 :: u0 -> u0 -> u0) (u5 :: u0 -> u0) (u6 :: u0 -> Int -> u0) (u7 :: u0 -> Int -> u0) (u8 :: u0 -> u0) (u9 :: u0) (ua :: u0 -> Int) -> u6; _NO_DEFLT_ } _N_
		{-defm-} _A_ 3 _U_ 022 _N_ _S_ _!_ _F_ _IF_ARGS_ 1 3 XXX 4 _/\_ u0 -> \ (u1 :: {{Bits u0}}) (u2 :: u0) (u3 :: Int) -> _APP_  _TYAPP_  patError# { (u0 -> Int -> u0) } [ _NOREP_S_ "%DWord2.Bits.bitRsh\"", u2, u3 ] _N_ #-}
	bitLsh :: a -> Int -> a
	 {-# GHC_PRAGMA {-meth-} _A_ 1 _U_ 122 _N_ _S_ "U(AAAAASAAA)" {_A_ 1 _U_ 122 _N_ _N_ _F_ _IF_ARGS_ 1 1 X 1 _/\_ u0 -> \ (u1 :: u0 -> Int -> u0) -> u1 _N_} _F_ _IF_ARGS_ 1 1 C 2 _/\_ u0 -> \ (u1 :: (u0 -> u0 -> u0, u0 -> u0 -> u0, u0 -> u0 -> u0, u0 -> u0, u0 -> Int -> u0, u0 -> Int -> u0, u0 -> u0, u0, u0 -> Int)) -> case u1 of { _ALG_ _TUP_9 (u2 :: u0 -> u0 -> u0) (u3 :: u0 -> u0 -> u0) (u4 :: u0 -> u0 -> u0) (u5 :: u0 -> u0) (u6 :: u0 -> Int -> u0) (u7 :: u0 -> Int -> u0) (u8 :: u0 -> u0) (u9 :: u0) (ua :: u0 -> Int) -> u7; _NO_DEFLT_ } _N_
		{-defm-} _A_ 3 _U_ 022 _N_ _S_ _!_ _F_ _IF_ARGS_ 1 3 XXX 4 _/\_ u0 -> \ (u1 :: {{Bits u0}}) (u2 :: u0) (u3 :: Int) -> _APP_  _TYAPP_  patError# { (u0 -> Int -> u0) } [ _NOREP_S_ "%DWord2.Bits.bitLsh\"", u2, u3 ] _N_ #-}
	bitSwap :: a -> a
	 {-# GHC_PRAGMA {-meth-} _A_ 1 _U_ 12 _N_ _S_ "U(AAAAAASAA)" {_A_ 1 _U_ 12 _N_ _N_ _F_ _IF_ARGS_ 1 1 X 1 _/\_ u0 -> \ (u1 :: u0 -> u0) -> u1 _N_} _F_ _IF_ARGS_ 1 1 C 2 _/\_ u0 -> \ (u1 :: (u0 -> u0 -> u0, u0 -> u0 -> u0, u0 -> u0 -> u0, u0 -> u0, u0 -> Int -> u0, u0 -> Int -> u0, u0 -> u0, u0, u0 -> Int)) -> case u1 of { _ALG_ _TUP_9 (u2 :: u0 -> u0 -> u0) (u3 :: u0 -> u0 -> u0) (u4 :: u0 -> u0 -> u0) (u5 :: u0 -> u0) (u6 :: u0 -> Int -> u0) (u7 :: u0 -> Int -> u0) (u8 :: u0 -> u0) (u9 :: u0) (ua :: u0 -> Int) -> u8; _NO_DEFLT_ } _N_
		{-defm-} _A_ 2 _U_ 02 _N_ _S_ _!_ _F_ _IF_ARGS_ 1 2 XX 3 _/\_ u0 -> \ (u1 :: {{Bits u0}}) (u2 :: u0) -> _APP_  _TYAPP_  patError# { (u0 -> u0) } [ _NOREP_S_ "%DWord2.Bits.bitSwap\"", u2 ] _N_ #-}
	bit0 :: a
	 {-# GHC_PRAGMA {-meth-} _A_ 1 _U_ 1 _N_ _S_ "U(AAAAAAASA)" {_A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 1 1 X 1 _/\_ u0 -> \ (u1 :: u0) -> u1 _N_} _F_ _IF_ARGS_ 1 1 C 2 _/\_ u0 -> \ (u1 :: (u0 -> u0 -> u0, u0 -> u0 -> u0, u0 -> u0 -> u0, u0 -> u0, u0 -> Int -> u0, u0 -> Int -> u0, u0 -> u0, u0, u0 -> Int)) -> case u1 of { _ALG_ _TUP_9 (u2 :: u0 -> u0 -> u0) (u3 :: u0 -> u0 -> u0) (u4 :: u0 -> u0 -> u0) (u5 :: u0 -> u0) (u6 :: u0 -> Int -> u0) (u7 :: u0 -> Int -> u0) (u8 :: u0 -> u0) (u9 :: u0) (ua :: u0 -> Int) -> u9; _NO_DEFLT_ } _N_
		{-defm-} _A_ 1 _U_ 0 _N_ _S_ _!_ _F_ _IF_ARGS_ 1 1 X 2 _/\_ u0 -> \ (u1 :: {{Bits u0}}) -> _APP_  _TYAPP_  patError# { u0 } [ _NOREP_S_ "%DWord2.Bits.bit0\"" ] _N_ #-}
	bitSize :: a -> Int
	 {-# GHC_PRAGMA {-meth-} _A_ 1 _U_ 12 _N_ _S_ "U(AAAAAAAAS)" {_A_ 1 _U_ 12 _N_ _N_ _F_ _IF_ARGS_ 1 1 X 1 _/\_ u0 -> \ (u1 :: u0 -> Int) -> u1 _N_} _F_ _IF_ARGS_ 1 1 C 2 _/\_ u0 -> \ (u1 :: (u0 -> u0 -> u0, u0 -> u0 -> u0, u0 -> u0 -> u0, u0 -> u0, u0 -> Int -> u0, u0 -> Int -> u0, u0 -> u0, u0, u0 -> Int)) -> case u1 of { _ALG_ _TUP_9 (u2 :: u0 -> u0 -> u0) (u3 :: u0 -> u0 -> u0) (u4 :: u0 -> u0 -> u0) (u5 :: u0 -> u0) (u6 :: u0 -> Int -> u0) (u7 :: u0 -> Int -> u0) (u8 :: u0 -> u0) (u9 :: u0) (ua :: u0 -> Int) -> ua; _NO_DEFLT_ } _N_
		{-defm-} _A_ 2 _U_ 02 _N_ _S_ _!_ _F_ _IF_ARGS_ 1 2 XX 3 _/\_ u0 -> \ (u1 :: {{Bits u0}}) (u2 :: u0) -> _APP_  _TYAPP_  patError# { (u0 -> Int) } [ _NOREP_S_ "%DWord2.Bits.bitSize\"", u2 ] _N_ #-}
data Byte 	{-# GHC_PRAGMA Byte Int# #-}
data Short 	{-# GHC_PRAGMA Short Int# #-}
data Word 	{-# GHC_PRAGMA Word Word# #-}
byteToInt :: Byte -> Int
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 2 \ (u0 :: Int#) -> _!_ I# [] [u0] _N_} _F_ _IF_ARGS_ 0 1 C 3 \ (u0 :: Byte) -> case u0 of { _ALG_ _ORIG_ Word2 Byte (u1 :: Int#) -> _!_ I# [] [u1]; _NO_DEFLT_ } _N_ #-}
shortToInt :: Short -> Int
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 2 \ (u0 :: Int#) -> _!_ I# [] [u0] _N_} _F_ _IF_ARGS_ 0 1 C 3 \ (u0 :: Short) -> case u0 of { _ALG_ _ORIG_ Word2 Short (u1 :: Int#) -> _!_ I# [] [u1]; _NO_DEFLT_ } _N_ #-}
wordToInt :: Word -> Int
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Word#) -> case _#_ word2Int# [] [u0] of { _PRIM_ (u1 :: Int#) -> _!_ I# [] [u1] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Word) -> case u0 of { _ALG_ _ORIG_ Word2 Word (u1 :: Word#) -> case _#_ word2Int# [] [u1] of { _PRIM_ (u2 :: Int#) -> _!_ I# [] [u2] }; _NO_DEFLT_ } _N_ #-}
instance Eq Byte
	{-# GHC_PRAGMA _M_ Word2 {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Byte -> Byte -> Bool), (Byte -> Byte -> Bool)] [_CONSTM_ Eq (==) (Byte), _CONSTM_ Eq (/=) (Byte)] _N_
	 (==) = _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 1 \ (u0 :: Int#) (u1 :: Int#) -> _#_ eqInt# [] [u0, u1] _N_} _F_ _IF_ARGS_ 0 2 CC 3 \ (u0 :: Byte) (u1 :: Byte) -> case u0 of { _ALG_ _ORIG_ Word2 Byte (u2 :: Int#) -> case u1 of { _ALG_ _ORIG_ Word2 Byte (u3 :: Int#) -> _#_ eqInt# [] [u2, u3]; _NO_DEFLT_ }; _NO_DEFLT_ } _N_,
	 (/=) = _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 5 \ (u0 :: Int#) (u1 :: Int#) -> case _#_ eqInt# [] [u0, u1] of { _ALG_ True  -> _!_ False [] []; False  -> _!_ True [] []; _NO_DEFLT_ } _N_} _F_ _IF_ARGS_ 0 2 CC 7 \ (u0 :: Byte) (u1 :: Byte) -> case u0 of { _ALG_ _ORIG_ Word2 Byte (u2 :: Int#) -> case u1 of { _ALG_ _ORIG_ Word2 Byte (u3 :: Int#) -> case _#_ eqInt# [] [u2, u3] of { _ALG_ True  -> _!_ False [] []; False  -> _!_ True [] []; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ #-}
instance Eq Short
	{-# GHC_PRAGMA _M_ Word2 {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Short -> Short -> Bool), (Short -> Short -> Bool)] [_CONSTM_ Eq (==) (Short), _CONSTM_ Eq (/=) (Short)] _N_
	 (==) = _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 1 \ (u0 :: Int#) (u1 :: Int#) -> _#_ eqInt# [] [u0, u1] _N_} _F_ _IF_ARGS_ 0 2 CC 3 \ (u0 :: Short) (u1 :: Short) -> case u0 of { _ALG_ _ORIG_ Word2 Short (u2 :: Int#) -> case u1 of { _ALG_ _ORIG_ Word2 Short (u3 :: Int#) -> _#_ eqInt# [] [u2, u3]; _NO_DEFLT_ }; _NO_DEFLT_ } _N_,
	 (/=) = _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 5 \ (u0 :: Int#) (u1 :: Int#) -> case _#_ eqInt# [] [u0, u1] of { _ALG_ True  -> _!_ False [] []; False  -> _!_ True [] []; _NO_DEFLT_ } _N_} _F_ _IF_ARGS_ 0 2 CC 7 \ (u0 :: Short) (u1 :: Short) -> case u0 of { _ALG_ _ORIG_ Word2 Short (u2 :: Int#) -> case u1 of { _ALG_ _ORIG_ Word2 Short (u3 :: Int#) -> case _#_ eqInt# [] [u2, u3] of { _ALG_ True  -> _!_ False [] []; False  -> _!_ True [] []; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ #-}
instance Eq Word
	{-# GHC_PRAGMA _M_ Word2 {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Word -> Word -> Bool), (Word -> Word -> Bool)] [_CONSTM_ Eq (==) (Word), _CONSTM_ Eq (/=) (Word)] _N_
	 (==) = _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 1 \ (u0 :: Word#) (u1 :: Word#) -> _#_ eqWord# [] [u0, u1] _N_} _F_ _IF_ARGS_ 0 2 CC 3 \ (u0 :: Word) (u1 :: Word) -> case u0 of { _ALG_ _ORIG_ Word2 Word (u2 :: Word#) -> case u1 of { _ALG_ _ORIG_ Word2 Word (u3 :: Word#) -> _#_ eqWord# [] [u2, u3]; _NO_DEFLT_ }; _NO_DEFLT_ } _N_,
	 (/=) = _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 5 \ (u0 :: Word#) (u1 :: Word#) -> case _#_ eqWord# [] [u0, u1] of { _ALG_ True  -> _!_ False [] []; False  -> _!_ True [] []; _NO_DEFLT_ } _N_} _F_ _IF_ARGS_ 0 2 CC 7 \ (u0 :: Word) (u1 :: Word) -> case u0 of { _ALG_ _ORIG_ Word2 Word (u2 :: Word#) -> case u1 of { _ALG_ _ORIG_ Word2 Word (u3 :: Word#) -> case _#_ eqWord# [] [u2, u3] of { _ALG_ True  -> _!_ False [] []; False  -> _!_ True [] []; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ #-}
instance Num Word
	{-# GHC_PRAGMA _M_ Word2 {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 11 _!_ _TUP_10 [{{Eq Word}}, {{Text Word}}, (Word -> Word -> Word), (Word -> Word -> Word), (Word -> Word -> Word), (Word -> Word), (Word -> Word), (Word -> Word), (Integer -> Word), (Int -> Word)] [_DFUN_ Eq (Word), _DFUN_ Text (Word), _CONSTM_ Num (+) (Word), _CONSTM_ Num (-) (Word), _CONSTM_ Num (*) (Word), _CONSTM_ Num negate (Word), _CONSTM_ Num abs (Word), _CONSTM_ Num signum (Word), _CONSTM_ Num fromInteger (Word), _CONSTM_ Num fromInt (Word)] _N_
	 (+) = _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_,
	 (-) = _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_,
	 (*) = _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_,
	 negate = _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_,
	 abs = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Word) -> _APP_  _TYAPP_  patError# { (Word -> Word) } [ _NOREP_S_ "%DPreludeCore.Num.abs\"", u0 ] _N_,
	 signum = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Word) -> _APP_  _TYAPP_  patError# { (Word -> Word) } [ _NOREP_S_ "%DPreludeCore.Num.signum\"", u0 ] _N_,
	 fromInteger = _A_ 1 _U_ 1 _N_ _S_ "U(PPP)" {_A_ 3 _U_ 222 _N_ _N_ _F_ _IF_ARGS_ 0 3 XXX 4 \ (u0 :: Int#) (u1 :: Int#) (u2 :: ByteArray#) -> case _#_ integer2Int# [] [u0, u1, u2] of { _PRIM_ (u3 :: Int#) -> case _#_ int2Word# [] [u3] of { _PRIM_ (u4 :: Word#) -> _!_ _ORIG_ Word2 Word [] [u4] } } _N_} _F_ _IF_ARGS_ 0 1 C 5 \ (u0 :: Integer) -> case u0 of { _ALG_ J# (u1 :: Int#) (u2 :: Int#) (u3 :: ByteArray#) -> case _#_ integer2Int# [] [u1, u2, u3] of { _PRIM_ (u4 :: Int#) -> case _#_ int2Word# [] [u4] of { _PRIM_ (u5 :: Word#) -> _!_ _ORIG_ Word2 Word [] [u5] } }; _NO_DEFLT_ } _N_,
	 fromInt = _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _F_ _IF_ARGS_ 0 1 C 5 \ (u0 :: Int) -> let {(u2 :: Integer) = case u0 of { _ALG_ I# (u1 :: Int#) -> _#_ int2Integer# [] [u1]; _NO_DEFLT_ }} in _APP_  _CONSTM_ Num fromInteger (Word) [ u2 ] _N_ #-}
instance Ord Byte
	{-# GHC_PRAGMA _M_ Word2 {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 9 _!_ _TUP_8 [{{Eq Byte}}, (Byte -> Byte -> Bool), (Byte -> Byte -> Bool), (Byte -> Byte -> Bool), (Byte -> Byte -> Bool), (Byte -> Byte -> Byte), (Byte -> Byte -> Byte), (Byte -> Byte -> _CMP_TAG)] [_DFUN_ Eq (Byte), _CONSTM_ Ord (<) (Byte), _CONSTM_ Ord (<=) (Byte), _CONSTM_ Ord (>=) (Byte), _CONSTM_ Ord (>) (Byte), _CONSTM_ Ord max (Byte), _CONSTM_ Ord min (Byte), _CONSTM_ Ord _tagCmp (Byte)] _N_
	 (<) = _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_,
	 (<=) = _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_,
	 (>=) = _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_,
	 (>) = _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_,
	 max = _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_,
	 min = _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_,
	 _tagCmp = _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
instance Ord Short
	{-# GHC_PRAGMA _M_ Word2 {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 9 _!_ _TUP_8 [{{Eq Short}}, (Short -> Short -> Bool), (Short -> Short -> Bool), (Short -> Short -> Bool), (Short -> Short -> Bool), (Short -> Short -> Short), (Short -> Short -> Short), (Short -> Short -> _CMP_TAG)] [_DFUN_ Eq (Short), _CONSTM_ Ord (<) (Short), _CONSTM_ Ord (<=) (Short), _CONSTM_ Ord (>=) (Short), _CONSTM_ Ord (>) (Short), _CONSTM_ Ord max (Short), _CONSTM_ Ord min (Short), _CONSTM_ Ord _tagCmp (Short)] _N_
	 (<) = _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_,
	 (<=) = _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_,
	 (>=) = _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_,
	 (>) = _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_,
	 max = _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_,
	 min = _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_,
	 _tagCmp = _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
instance Ord Word
	{-# GHC_PRAGMA _M_ Word2 {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 9 _!_ _TUP_8 [{{Eq Word}}, (Word -> Word -> Bool), (Word -> Word -> Bool), (Word -> Word -> Bool), (Word -> Word -> Bool), (Word -> Word -> Word), (Word -> Word -> Word), (Word -> Word -> _CMP_TAG)] [_DFUN_ Eq (Word), _CONSTM_ Ord (<) (Word), _CONSTM_ Ord (<=) (Word), _CONSTM_ Ord (>=) (Word), _CONSTM_ Ord (>) (Word), _CONSTM_ Ord max (Word), _CONSTM_ Ord min (Word), _CONSTM_ Ord _tagCmp (Word)] _N_
	 (<) = _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_,
	 (<=) = _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_,
	 (>=) = _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_,
	 (>) = _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_,
	 max = _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_,
	 min = _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_,
	 _tagCmp = _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
instance Text Word
	{-# GHC_PRAGMA _M_ Word2 {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 5 _!_ _TUP_4 [(Int -> [Char] -> [(Word, [Char])]), (Int -> Word -> [Char] -> [Char]), ([Char] -> [([Word], [Char])]), ([Word] -> [Char] -> [Char])] [_CONSTM_ Text readsPrec (Word), _CONSTM_ Text showsPrec (Word), _CONSTM_ Text readList (Word), _CONSTM_ Text showList (Word)] _N_
	 readsPrec = _A_ 2 _U_ 22 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 2 XX 4 \ (u0 :: Int) (u1 :: [Char]) -> _APP_  _TYAPP_  patError# { (Int -> [Char] -> [(Word, [Char])]) } [ _NOREP_S_ "%DPreludeCore.Text.readsPrec\"", u0, u1 ] _N_,
	 showsPrec = _A_ 2 _U_ 012 _N_ _S_ "AU(P)" {_A_ 1 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_,
	 readList = _A_ 0 _U_ 2 _N_ _N_ _N_ _N_,
	 showList = _A_ 0 _U_ 12 _N_ _N_ _N_ _N_ #-}
instance Bits Word
	{-# GHC_PRAGMA _M_ Word2 {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 10 _!_ _TUP_9 [(Word -> Word -> Word), (Word -> Word -> Word), (Word -> Word -> Word), (Word -> Word), (Word -> Int -> Word), (Word -> Int -> Word), (Word -> Word), Word, (Word -> Int)] [_CONSTM_ Bits bitAnd (Word), _CONSTM_ Bits bitOr (Word), _CONSTM_ Bits bitXor (Word), _CONSTM_ Bits bitCompl (Word), _CONSTM_ Bits bitRsh (Word), _CONSTM_ Bits bitLsh (Word), _CONSTM_ Bits bitSwap (Word), _CONSTM_ Bits bit0 (Word), _CONSTM_ Bits bitSize (Word)] _N_
	 bitAnd = _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 3 \ (u0 :: Word#) (u1 :: Word#) -> case _#_ and# [] [u0, u1] of { _PRIM_ (u2 :: Word#) -> _!_ _ORIG_ Word2 Word [] [u2] } _N_} _F_ _IF_ARGS_ 0 2 CC 5 \ (u0 :: Word) (u1 :: Word) -> case u0 of { _ALG_ _ORIG_ Word2 Word (u2 :: Word#) -> case u1 of { _ALG_ _ORIG_ Word2 Word (u3 :: Word#) -> case _#_ and# [] [u2, u3] of { _PRIM_ (u4 :: Word#) -> _!_ _ORIG_ Word2 Word [] [u4] }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_,
	 bitOr = _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 3 \ (u0 :: Word#) (u1 :: Word#) -> case _#_ or# [] [u0, u1] of { _PRIM_ (u2 :: Word#) -> _!_ _ORIG_ Word2 Word [] [u2] } _N_} _F_ _IF_ARGS_ 0 2 CC 5 \ (u0 :: Word) (u1 :: Word) -> case u0 of { _ALG_ _ORIG_ Word2 Word (u2 :: Word#) -> case u1 of { _ALG_ _ORIG_ Word2 Word (u3 :: Word#) -> case _#_ or# [] [u2, u3] of { _PRIM_ (u4 :: Word#) -> _!_ _ORIG_ Word2 Word [] [u4] }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_,
	 bitXor = _A_ 2 _U_ 11 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 2 CC 4 \ (u0 :: Word) (u1 :: Word) -> case u0 of { _ALG_ _ORIG_ Word2 Word (u2 :: Word#) -> case u1 of { _ALG_ _ORIG_ Word2 Word (u3 :: Word#) -> _APP_  _TYAPP_  error { Word } [ _NOREP_S_ "later..." ]; _NO_DEFLT_ }; _NO_DEFLT_ } _N_,
	 bitCompl = _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Word#) -> case _#_ not# [] [u0] of { _PRIM_ (u1 :: Word#) -> _!_ _ORIG_ Word2 Word [] [u1] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Word) -> case u0 of { _ALG_ _ORIG_ Word2 Word (u1 :: Word#) -> case _#_ not# [] [u1] of { _PRIM_ (u2 :: Word#) -> _!_ _ORIG_ Word2 Word [] [u2] }; _NO_DEFLT_ } _N_,
	 bitRsh = _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 3 \ (u0 :: Word#) (u1 :: Int#) -> case _#_ shiftRA# [] [u0, u1] of { _PRIM_ (u2 :: Word#) -> _!_ _ORIG_ Word2 Word [] [u2] } _N_} _F_ _IF_ARGS_ 0 2 CC 5 \ (u0 :: Word) (u1 :: Int) -> case u0 of { _ALG_ _ORIG_ Word2 Word (u2 :: Word#) -> case u1 of { _ALG_ I# (u3 :: Int#) -> case _#_ shiftRA# [] [u2, u3] of { _PRIM_ (u4 :: Word#) -> _!_ _ORIG_ Word2 Word [] [u4] }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_,
	 bitLsh = _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 3 \ (u0 :: Word#) (u1 :: Int#) -> case _#_ shiftL# [] [u0, u1] of { _PRIM_ (u2 :: Word#) -> _!_ _ORIG_ Word2 Word [] [u2] } _N_} _F_ _IF_ARGS_ 0 2 CC 5 \ (u0 :: Word) (u1 :: Int) -> case u0 of { _ALG_ _ORIG_ Word2 Word (u2 :: Word#) -> case u1 of { _ALG_ I# (u3 :: Int#) -> case _#_ shiftL# [] [u2, u3] of { _PRIM_ (u4 :: Word#) -> _!_ _ORIG_ Word2 Word [] [u4] }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_,
	 bitSwap = _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_,
	 bit0 = _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 case _#_ int2Word# [] [1#] of { _PRIM_ (u0 :: Word#) -> _!_ _ORIG_ Word2 Word [] [u0] } _N_,
	 bitSize = _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 0 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 2 \ (u0 :: Word#) -> _!_ I# [] [32#] _N_} _F_ _IF_ARGS_ 0 1 C 3 \ (u0 :: Word) -> case u0 of { _ALG_ _ORIG_ Word2 Word (u1 :: Word#) -> _!_ I# [] [32#]; _NO_DEFLT_ } _N_ #-}

