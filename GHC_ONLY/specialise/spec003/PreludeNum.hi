{-# GHC_PRAGMA INTERFACE VERSION 4 #-}
interface PreludeNum where
f1 :: Int#
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _F_ _ALWAYS_ case _APP_  _SPEC_ _ORIG_ PreludeNum fac [ (Int#) ] [ 10# ] of { _PRIM_ (u0 :: Int#) -> _!_ _Lift [Int#] [u0] } _N_ #-}
f2 :: Int#
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _N_ _N_ #-}
f3 :: Int#
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _N_ _N_ #-}
fac :: Num a => a -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 12 _S_ "U(U(SA)AALLAAAAL)" {_A_ 4 _U_ 22222 _N_ _N_ _N_} _N_ _SPECIALISE_ [ Int# ] 1 { _A_ 1 _U_ 2 _S_ "P" _N_ _N_ } #-}
fac_two :: (Num c, Num b) => b -> a -> (b, c)
	{-# GHC_PRAGMA _A_ 2 _U_ 1122 _S_ "LU(U(SA)AALLAAAAL)" {_A_ 5 _U_ 1222222 _N_ _N_ _N_} _N_ _SPECIALISE_ [ _N_, Int, Int# ] 2 { _A_ 2 _U_ 12 _S_ "U(P)L" {_A_ 2 _U_ 22 _N_ _N_ _N_} _N_ _N_ }, [ Int#, Int#, Int ] 2 { _A_ 2 _U_ 22 _S_ "PP" _N_ _N_ } #-}
instance Eq Int#
	{-# GHC_PRAGMA _M_ PreludeNum {-dfun-} _A_ 0 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Int# -> Int# -> Bool), (Int# -> Int# -> Bool)] [_CONSTM_ Eq (==) (Int#), _CONSTM_ Eq (/=) (Int#)] _N_
	 (==) = _A_ 2 _U_ 22 _S_ "PP" _F_ _IF_ARGS_ 0 2 XX 1 \ (u0 :: Int#) (u1 :: Int#) -> _#_ eqInt# [] [u0, u1] _N_,
	 (/=) = _A_ 2 _U_ 22 _S_ "PP" _F_ _IF_ARGS_ 0 2 XX 1 \ (u0 :: Int#) (u1 :: Int#) -> _#_ neInt# [] [u0, u1] _N_ #-}
instance Num Int#
	{-# GHC_PRAGMA _M_ PreludeNum {-dfun-} _A_ 0 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 11 _!_ _TUP_10 [{{Eq Int#}}, {{Text Int#}}, (Int# -> Int# -> Int#), (Int# -> Int# -> Int#), (Int# -> Int# -> Int#), (Int# -> Int#), (Int# -> Int#), (Int# -> Int#), (Integer -> Int#), (Int -> Int#)] [_DFUN_ Eq (Int#), _DFUN_ Text (Int#), _CONSTM_ Num (+) (Int#), _CONSTM_ Num (-) (Int#), _CONSTM_ Num (*) (Int#), _CONSTM_ Num negate (Int#), _CONSTM_ Num abs (Int#), _CONSTM_ Num signum (Int#), _CONSTM_ Num fromInteger (Int#), _CONSTM_ Num fromInt (Int#)] _N_
	 (+) = _A_ 2 _U_ 22 _S_ "PP" _F_ _IF_ARGS_ 0 2 XX 1 \ (u0 :: Int#) (u1 :: Int#) -> _#_ plusInt# [] [u0, u1] _N_,
	 (-) = _A_ 2 _U_ 22 _S_ "PP" _F_ _IF_ARGS_ 0 2 XX 1 \ (u0 :: Int#) (u1 :: Int#) -> _#_ minusInt# [] [u0, u1] _N_,
	 (*) = _A_ 2 _U_ 22 _S_ "PP" _F_ _IF_ARGS_ 0 2 XX 1 \ (u0 :: Int#) (u1 :: Int#) -> _#_ timesInt# [] [u0, u1] _N_,
	 negate = _A_ 1 _U_ 2 _S_ "P" _F_ _IF_ARGS_ 0 1 X 1 \ (u0 :: Int#) -> _#_ negateInt# [] [u0] _N_,
	 abs = _A_ 1 _U_ 2 _S_ "P" _N_ _N_,
	 signum = _A_ 1 _U_ 2 _S_ "P" _N_ _N_,
	 fromInteger = _A_ 1 _U_ 1 _S_ "U(PPP)" {_A_ 3 _U_ 222 _N_ _F_ _IF_ARGS_ 0 3 XXX 1 \ (u0 :: Int#) (u1 :: Int#) (u2 :: ByteArray#) -> _#_ integer2Int# [] [u0, u1, u2] _N_} _F_ _IF_ARGS_ 0 1 C 2 \ (u0 :: Integer) -> case u0 of { _ALG_ J# (u1 :: Int#) (u2 :: Int#) (u3 :: ByteArray#) -> _#_ integer2Int# [] [u1, u2, u3]; _NO_DEFLT_ } _N_,
	 fromInt = _A_ 1 _U_ 1 _S_ "U(P)" {_A_ 1 _U_ 1 _N_ _F_ _IF_ARGS_ 0 1 X 1 \ (u0 :: Int#) -> u0 _N_} _F_ _IF_ARGS_ 0 1 C 2 \ (u0 :: Int) -> case u0 of { _ALG_ I# (u1 :: Int#) -> u1; _NO_DEFLT_ } _N_ #-}
instance Text Int#
	{-# GHC_PRAGMA _M_ PreludeNum {-dfun-} _A_ 0 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 5 _!_ _TUP_4 [(Int -> [Char] -> [(Int#, [Char])]), (Int -> Int# -> [Char] -> [Char]), ([Char] -> [([Int#], [Char])]), ([Int#] -> [Char] -> [Char])] [_CONSTM_ Text readsPrec (Int#), _WRKR_ _CONSTM_ Text showsPrec (Int), _CONSTM_ Text readList (Int#), _CONSTM_ Text showList (Int#)] _N_
	 readsPrec = _A_ 2 _U_ 02 _S_ "AL" {_A_ 1 _U_ 2 _N_ _N_ _N_} _N_ _N_,
	 showsPrec = _A_ 3 _U_ 222 _N_ _N_ _N_,
	 readList = _A_ 1 _U_ 2 _N_ _N_ _N_,
	 showList = _A_ 1 _U_ 12 _S_ "S" _N_ _N_ #-}

