CHAR I/O:
*********

In clausify ...

The unifier would like to propogate use of Char#s all the way to the
readChan and appendChan. However these have explicit [Char] arguments
so we must explicitly coerce the Chars as we extract them.
	clause produces [Char#]s
	parse reads [Char] and builds Sym Char#
	disp takes [Char#]s and produces [Char]

COMMENTS:
* The extent of this unboxification is quite surprising and possibly
  unexpected.
* Coersion when constructing or extracting from unboxed structures can
  be a pain. Where this occurs defines the extent of the unboxedness.

OVERLOADING CHARS:

Might want to introduce versions of I/O operations which read/write
[Char#]. Use a type class to capture either boxed or unboxed Chars.

class Char a 
  toChar :: a -> Char
  fromChar :: Char -> a

instance Char Char
  toChar   = id
  fromChar = id

instance Char Char#
  toChar c#  = MkChar c#
  fromChar c = case c of MkChar c# -> c#

Now rather than specifying type as
   ... Char ...
We use
   Char c => ... c ...

Now just need a specialised versions I/O operations which deal with [Char#]

The Char class is very similar to the overloading of numeric constants.
