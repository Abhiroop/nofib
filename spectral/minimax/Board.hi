{-# GHC_PRAGMA INTERFACE VERSION 5 #-}
interface Board where
type Board = [[Piece]]
data Evaluation   = XWin | OWin | Score Int
data Piece   = X | O | Empty
type Row = [Piece]
empty :: (Int, Int) -> [[Piece]] -> Bool
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "U(U(P)U(P))S" {_A_ 3 _U_ 111 _N_ _N_ _N_ _N_} _N_ _N_ #-}
empty' :: Int -> [Piece] -> Bool
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "U(P)L" {_A_ 2 _U_ 11 _N_ _N_ _N_ _N_} _N_ _N_ #-}
eval :: Int -> Evaluation
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _F_ _IF_ARGS_ 0 1 C 5 \ (u0 :: Int) -> case u0 of { _ALG_ I# (u1 :: Int#) -> case u1 of { _PRIM_ 3# -> _!_ _ORIG_ Board XWin [] []; -3# -> _!_ _ORIG_ Board OWin [] []; (u2 :: Int#) -> _!_ _ORIG_ Board Score [] [u0] }; _NO_DEFLT_ } _N_ #-}
fullBoard :: [[Piece]] -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
initialBoard :: [[Piece]]
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _N_ _N_ _N_ #-}
insert :: Piece -> [Piece] -> Int -> [Piece]
	{-# GHC_PRAGMA _A_ 3 _U_ 211 _N_ _S_ "LSU(P)" {_A_ 3 _U_ 211 _N_ _N_ _N_ _N_} _N_ _N_ #-}
interpret :: Int -> [Evaluation] -> Evaluation
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ #-}
map2 :: (a -> b -> c) -> [a] -> [b] -> [c]
	{-# GHC_PRAGMA _A_ 3 _U_ 211 _N_ _S_ "LSL" _N_ _N_ #-}
newPositions :: Piece -> [[Piece]] -> [[[Piece]]]
	{-# GHC_PRAGMA _A_ 0 _U_ 22 _N_ _N_ _N_ _N_ #-}
placePiece :: Piece -> [[Piece]] -> (Int, Int) -> [[[Piece]]]
	{-# GHC_PRAGMA _A_ 3 _U_ 221 _N_ _S_ "LSU(U(P)U(P))" {_A_ 4 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
score :: [[Piece]] -> [[Int]] -> Evaluation
	{-# GHC_PRAGMA _A_ 0 _U_ 11 _N_ _N_ _N_ _N_ #-}
scorePiece :: Piece -> Int -> Int
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "EL" _N_ _N_ #-}
showBoard :: [[Piece]] -> [Char]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
showPiece :: Piece -> [Char]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "E" _N_ _N_ #-}
showRow :: [Piece] -> [Char]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
static :: [[Piece]] -> Evaluation
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ #-}
instance Eq Evaluation
	{-# GHC_PRAGMA _M_ Board {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Evaluation -> Evaluation -> Bool), (Evaluation -> Evaluation -> Bool)] [_CONSTM_ Eq (==) (Evaluation), _CONSTM_ Eq (/=) (Evaluation)] _N_
	 (==) = _A_ 2 _U_ 22 _N_ _S_ "SS" _N_ _N_,
	 (/=) = _A_ 2 _U_ 22 _N_ _S_ "SS" _N_ _N_ #-}
instance Eq Piece
	{-# GHC_PRAGMA _M_ Board {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Piece -> Piece -> Bool), (Piece -> Piece -> Bool)] [_CONSTM_ Eq (==) (Piece), _CONSTM_ Eq (/=) (Piece)] _N_
	 (==) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_,
	 (/=) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_ #-}
instance Text Evaluation
	{-# GHC_PRAGMA _M_ Board {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 5 _!_ _TUP_4 [(Int -> [Char] -> [(Evaluation, [Char])]), (Int -> Evaluation -> [Char] -> [Char]), ([Char] -> [([Evaluation], [Char])]), ([Evaluation] -> [Char] -> [Char])] [_CONSTM_ Text readsPrec (Evaluation), _CONSTM_ Text showsPrec (Evaluation), _CONSTM_ Text readList (Evaluation), _CONSTM_ Text showList (Evaluation)] _N_
	 readsPrec = _A_ 1 _U_ 12 _N_ _S_ "U(P)" {_A_ 1 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_,
	 showsPrec = _A_ 2 _U_ 112 _N_ _S_ "LS" _N_ _N_,
	 readList = _A_ 0 _U_ 2 _N_ _N_ _N_ _N_,
	 showList = _A_ 0 _U_ 12 _N_ _N_ _N_ _N_ #-}

