interface Fast2haskell where
abortstr :: [Char] -> [Response] -> [Request] {-# ARITY _ = 2 #-}
delay :: a -> [Response] -> [Request] {-# ARITY _ = 1 #-}
descr :: a -> b -> (a, b) {-# ARITY _ = 2 #-}
destr_update :: Ix a => Array a b -> a -> b -> Array a b {-# ARITY _ = 4 #-}
entier :: (Num b, RealFrac a) => a -> b {-# ARITY _ = 3 #-}
fix :: (a -> a) -> a {-# ARITY _ = 1 #-}
force :: a -> a {-# ARITY _ = 1 #-}
iff :: Bool -> a -> a -> a {-# ARITY _ = 3 #-}
iffrev :: a -> a -> Bool -> a {-# ARITY _ = 3 #-}
indassoc :: Assoc b a -> b {-# ARITY _ = 1 #-}
land_i :: Int -> Int -> Int {-# ARITY _ = 2 #-}
lnot_i :: Int -> Int {-# ARITY _ = 1 #-}
lor_i :: Int -> Int -> Int {-# ARITY _ = 2 #-}
lowbound :: (b, a) -> b {-# ARITY _ = 1 #-}
lshift_i :: Int -> Int -> Int {-# ARITY _ = 2 #-}
pair :: [a] -> Bool {-# ARITY _ = 1 #-}
rshift_i :: Int -> Int -> Int {-# ARITY _ = 2 #-}
seq :: a -> b -> b {-# ARITY _ = 2 #-}
strcmp :: [Char] -> [Char] -> Bool {-# ARITY _ = 2 #-}
tabulate :: (Enum a, Ix a) => (a -> b) -> (a, a) -> Array a b {-# ARITY _ = 4 #-}
upbound :: (a, b) -> b {-# ARITY _ = 1 #-}
update :: Ix a => Array a b -> a -> b -> Array a b {-# ARITY _ = 4 #-}
valassoc :: Assoc a b -> b {-# ARITY _ = 1 #-}
type Array_type a = Array Int a
type Assoc_type a = Assoc Int a
type Complex_type = Complex Double
type Descr_type = (Int, Int)
