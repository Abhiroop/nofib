{-# GHC_PRAGMA INTERFACE VERSION 5 #-}
interface ChessSetList where
data ChessSet 	{-# GHC_PRAGMA Board Int Int (Int, Int) [(Int, Int)] #-}
type Tile = (Int, Int)
addPiece :: (Int, Int) -> ChessSet -> ChessSet
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LU(LLLL)" {_A_ 5 _U_ 22122 _N_ _N_ _N_ _N_} _N_ _N_ #-}
createBoard :: Int -> (Int, Int) -> ChessSet
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _N_ _N_ _N_ #-}
deleteFirst :: ChessSet -> ChessSet
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(LLAL)" {_A_ 3 _U_ 211 _N_ _N_ _N_ _N_} _N_ _N_ #-}
firstPiece :: ChessSet -> (Int, Int)
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(AAU(LL)A)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 3 \ (u0 :: Int) (u1 :: Int) -> _!_ _TUP_2 [Int, Int] [u0, u1] _N_} _F_ _IF_ARGS_ 0 1 C 2 \ (u0 :: ChessSet) -> case u0 of { _ALG_ _ORIG_ ChessSetList Board (u1 :: Int) (u2 :: Int) (u3 :: (Int, Int)) (u4 :: [(Int, Int)]) -> u3; _NO_DEFLT_ } _N_ #-}
isSquareFree :: (Int, Int) -> ChessSet -> Bool
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LU(AAAS)" {_A_ 2 _U_ 21 _N_ _N_ _N_ _N_} _N_ _N_ #-}
lastPiece :: ChessSet -> (Int, Int)
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(AAAS)" {_A_ 1 _U_ 1 _N_ _N_ _N_ _N_} _N_ _N_ #-}
noPieces :: ChessSet -> Int
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(AU(P)AA)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 2 \ (u0 :: Int#) -> _!_ I# [] [u0] _N_} _F_ _IF_ARGS_ 0 1 C 2 \ (u0 :: ChessSet) -> case u0 of { _ALG_ _ORIG_ ChessSetList Board (u1 :: Int) (u2 :: Int) (u3 :: (Int, Int)) (u4 :: [(Int, Int)]) -> u2; _NO_DEFLT_ } _N_ #-}
pieceAtTile :: (Int, Int) -> ChessSet -> Int
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "U(U(P)U(P))U(AAAS)" {_A_ 3 _U_ 221 _N_ _N_ _N_ _N_} _N_ _N_ #-}
positionPiece :: Int -> ChessSet -> (Int, Int)
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "U(P)U(AU(P)AS)" {_A_ 3 _U_ 222 _N_ _N_ _F_ _IF_ARGS_ 0 3 XXX 4 \ (u0 :: Int#) (u1 :: Int#) (u2 :: [(Int, Int)]) -> case _#_ minusInt# [] [u1, u0] of { _PRIM_ (u3 :: Int#) -> _APP_  _TYAPP_  _WRKR_ _SPEC_ _ORIG_ PreludeList (!!) [ (Int), _N_ ] { (Int, Int) } [ u2, u3 ] } _N_} _F_ _IF_ARGS_ 0 2 CC 7 \ (u0 :: Int) (u1 :: ChessSet) -> case u1 of { _ALG_ _ORIG_ ChessSetList Board (u2 :: Int) (u3 :: Int) (u4 :: (Int, Int)) (u5 :: [(Int, Int)]) -> case u3 of { _ALG_ I# (u6 :: Int#) -> case u0 of { _ALG_ I# (u7 :: Int#) -> case _#_ minusInt# [] [u6, u7] of { _PRIM_ (u8 :: Int#) -> _APP_  _TYAPP_  _WRKR_ _SPEC_ _ORIG_ PreludeList (!!) [ (Int), _N_ ] { (Int, Int) } [ u5, u8 ] }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ #-}
sizeBoard :: ChessSet -> Int
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(U(P)AAA)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 2 \ (u0 :: Int#) -> _!_ I# [] [u0] _N_} _F_ _IF_ARGS_ 0 1 C 2 \ (u0 :: ChessSet) -> case u0 of { _ALG_ _ORIG_ ChessSetList Board (u1 :: Int) (u2 :: Int) (u3 :: (Int, Int)) (u4 :: [(Int, Int)]) -> u1; _NO_DEFLT_ } _N_ #-}
instance Eq ChessSet
	{-# GHC_PRAGMA _M_ ChessSetList {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(ChessSet -> ChessSet -> Bool), (ChessSet -> ChessSet -> Bool)] [_CONSTM_ Eq (==) (ChessSet), _CONSTM_ Eq (/=) (ChessSet)] _N_
	 (==) = _A_ 2 _U_ 00 _N_ _S_ "AA" {_A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _!_ True [] [] _N_} _F_ _IF_ARGS_ 0 2 XX 1 \ (u0 :: ChessSet) (u1 :: ChessSet) -> _!_ True [] [] _N_,
	 (/=) = _A_ 2 _U_ 22 _N_ _N_ _N_ _N_ #-}
instance Ord ChessSet
	{-# GHC_PRAGMA _M_ ChessSetList {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 9 _!_ _TUP_8 [{{Eq ChessSet}}, (ChessSet -> ChessSet -> Bool), (ChessSet -> ChessSet -> Bool), (ChessSet -> ChessSet -> Bool), (ChessSet -> ChessSet -> Bool), (ChessSet -> ChessSet -> ChessSet), (ChessSet -> ChessSet -> ChessSet), (ChessSet -> ChessSet -> _CMP_TAG)] [_DFUN_ Eq (ChessSet), _CONSTM_ Ord (<) (ChessSet), _CONSTM_ Ord (<=) (ChessSet), _CONSTM_ Ord (>=) (ChessSet), _CONSTM_ Ord (>) (ChessSet), _CONSTM_ Ord max (ChessSet), _CONSTM_ Ord min (ChessSet), _CONSTM_ Ord _tagCmp (ChessSet)] _N_
	 (<) = _A_ 2 _U_ 22 _N_ _N_ _N_ _N_,
	 (<=) = _A_ 2 _U_ 00 _N_ _S_ "AA" {_A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _!_ True [] [] _N_} _F_ _IF_ARGS_ 0 2 XX 1 \ (u0 :: ChessSet) (u1 :: ChessSet) -> _!_ True [] [] _N_,
	 (>=) = _A_ 2 _U_ 00 _N_ _S_ "AA" {_A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _!_ True [] [] _N_} _F_ _IF_ARGS_ 0 2 XX 1 \ (u0 :: ChessSet) (u1 :: ChessSet) -> _!_ True [] [] _N_,
	 (>) = _A_ 2 _U_ 22 _N_ _N_ _N_ _N_,
	 max = _A_ 2 _U_ 22 _N_ _N_ _N_ _N_,
	 min = _A_ 2 _U_ 22 _N_ _N_ _N_ _N_,
	 _tagCmp = _A_ 2 _U_ 22 _N_ _N_ _N_ _N_ #-}
instance Text ChessSet
	{-# GHC_PRAGMA _M_ ChessSetList {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 5 _!_ _TUP_4 [(Int -> [Char] -> [(ChessSet, [Char])]), (Int -> ChessSet -> [Char] -> [Char]), ([Char] -> [([ChessSet], [Char])]), ([ChessSet] -> [Char] -> [Char])] [_CONSTM_ Text readsPrec (ChessSet), _CONSTM_ Text showsPrec (ChessSet), _CONSTM_ Text readList (ChessSet), _CONSTM_ Text showList (ChessSet)] _N_
	 readsPrec = _A_ 2 _U_ 22 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 2 XX 4 \ (u0 :: Int) (u1 :: [Char]) -> _APP_  _TYAPP_  patError# { (Int -> [Char] -> [(ChessSet, [Char])]) } [ _NOREP_S_ "%DPreludeCore.Text.readsPrec\"", u0, u1 ] _N_,
	 showsPrec = _A_ 2 _U_ 012 _N_ _S_ "AU(U(P)LAL)" {_A_ 3 _U_ 2212 _N_ _N_ _N_ _N_} _N_ _N_,
	 readList = _A_ 0 _U_ 2 _N_ _N_ _N_ _N_,
	 showList = _A_ 0 _U_ 12 _N_ _N_ _N_ _N_ #-}

