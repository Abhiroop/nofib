{-# GHC_PRAGMA INTERFACE VERSION 5 #-}
interface Defs where
import Norm(Normal)
import S_Array(S_array)
type Det_Fac = (Float, ((Float, Float, Float), (Float, Float, Float)))
type Elem = ([Int], (Float, ((Float, Float, Float), (Float, Float, Float))))
type Frac_type = Float
type Node_Lists = (S_array ([(([Int], (Float, ((Float, Float, Float), (Float, Float, Float)))), Int)], Bool), S_array ([(([Int], (Float, ((Float, Float, Float), (Float, Float, Float)))), Int)], ((Float, Float), (Bool, (Bool, Bool)))))
type P_Node = ([(([Int], (Float, ((Float, Float, Float), (Float, Float, Float)))), Int)], Bool)
type Triple_F = (Float, Float, Float)
type V_Node = ([(([Int], (Float, ((Float, Float, Float), (Float, Float, Float)))), Int)], ((Float, Float), (Bool, (Bool, Bool))))
add_p :: S_array Float -> S_array Float -> S_array Float
	{-# GHC_PRAGMA _A_ 0 _U_ 11 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _APP_  _TYAPP_  _TYAPP_  _TYAPP_  _ORIG_ S_Array arr_merg { Float } { Float } { Float } [ _DFUN_ Normal (Float), _CONSTM_ Num (+) (Float) ] _N_ #-}
add_u :: S_array (Float, Float) -> S_array (Float, Float) -> S_array (Float, Float)
	{-# GHC_PRAGMA _A_ 0 _U_ 11 _N_ _N_ _N_ _N_ #-}
assemble :: (Normal a, Normal d) => ([a] -> c -> d) -> (b -> a) -> S_array ([b], c) -> S_array d
	{-# GHC_PRAGMA _A_ 2 _U_ 02221 _N_ _S_ "AL" {_A_ 1 _U_ 2221 _N_ _N_ _N_ _N_} _N_ _N_ #-}
get_val :: S_array a -> [Int] -> [a]
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ #-}
list_inner_prod :: [Float] -> [Float] -> Float
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "SL" _N_ _N_ #-}
p_nodel :: Int
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 2 _!_ I# [] [3#] _N_ #-}
v_nodel :: Int
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 2 _!_ I# [] [6#] _N_ #-}

