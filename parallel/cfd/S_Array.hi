{-# GHC_PRAGMA INTERFACE VERSION 5 #-}
interface S_Array where
import Norm(Normal(..))
import PreludeArray(Assoc)
infixl 9 !^
class Normal a where
	normal :: a -> Bool
	 {-# GHC_PRAGMA {-meth-} _A_ 1 _U_ 12 _N_ _S_ "S" _F_ _IF_ARGS_ 1 1 X 1 _/\_ u0 -> \ (u1 :: u0 -> Bool) -> u1 _N_
		{-defm-} _A_ 2 _U_ 02 _N_ _S_ _!_ _F_ _IF_ARGS_ 1 2 XX 3 _/\_ u0 -> \ (u1 :: {{Normal u0}}) (u2 :: u0) -> _APP_  _TYAPP_  patError# { (u0 -> Bool) } [ _NOREP_S_ "%DNorm.Normal.normal\"", u2 ] _N_ #-}
data Bin_Trie a   = Null | Leaf a | Fork Int (Bin_Trie a) (Bin_Trie a)
data Maybe a   = Nothing | Just a
type My_Array a b = S_array b
data S_array a   = Mk_t_Array (Int, Int) (Maybe a) (Bin_Trie a)
(!^) :: S_array a -> Int -> a
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "U(U(U(P)U(P))LS)U(P)" {_A_ 5 _U_ 22122 _N_ _N_ _N_ _N_} _N_ _N_ #-}
arr_merg :: Normal c => (a -> b -> c) -> S_array a -> S_array b -> S_array c
	{-# GHC_PRAGMA _A_ 1 _U_ 2211 _N_ _N_ _N_ _N_ #-}
arr_zip :: (Normal a, Normal b) => S_array a -> S_array b -> S_array (a, b)
	{-# GHC_PRAGMA _A_ 2 _U_ 2211 _N_ _N_ _N_ _N_ #-}
fork :: Int -> Bin_Trie a -> Bin_Trie a -> Bin_Trie a
	{-# GHC_PRAGMA _A_ 3 _U_ 222 _N_ _S_ "LSL" _N_ _N_ #-}
leaf :: Normal a => a -> Bin_Trie a
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _S_ "SL" _N_ _N_ #-}
s_accum :: (Normal b, Eq b) => (b -> a -> b) -> S_array b -> [Assoc Int a] -> S_array b
	{-# GHC_PRAGMA _A_ 2 _U_ 21212 _N_ _N_ _N_ _N_ #-}
s_accumArray :: (Normal b, Eq b) => (b -> a -> b) -> b -> (Int, Int) -> [Assoc Int a] -> S_array b
	{-# GHC_PRAGMA _A_ 2 _U_ 212222 _N_ _N_ _N_ _N_ #-}
s_amap :: Normal b => (a -> b) -> S_array a -> S_array b
	{-# GHC_PRAGMA _A_ 1 _U_ 221 _N_ _N_ _N_ _N_ #-}
s_bounds :: S_array a -> (Int, Int)
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(U(LL)AA)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 1 2 XX 3 _/\_ u0 -> \ (u1 :: Int) (u2 :: Int) -> _!_ _TUP_2 [Int, Int] [u1, u2] _N_} _F_ _IF_ARGS_ 1 1 C 2 _/\_ u0 -> \ (u1 :: S_array u0) -> case u1 of { _ALG_ _ORIG_ S_Array Mk_t_Array (u2 :: (Int, Int)) (u3 :: Maybe u0) (u4 :: Bin_Trie u0) -> u2; _NO_DEFLT_ } _N_ #-}
s_elems :: S_array a -> [a]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(LLS)" {_A_ 3 _U_ 111 _N_ _N_ _N_ _N_} _N_ _N_ #-}
s_listArray :: Normal a => (Int, Int) -> [a] -> S_array a
	{-# GHC_PRAGMA _A_ 1 _U_ 222 _N_ _N_ _N_ _N_ #-}
instance (Normal a, Normal b) => Normal (a, b)
	{-# GHC_PRAGMA _M_ Norm {-dfun-} _A_ 3 _U_ 22 _N_ _S_ "SSS" _N_ _N_ #-}
instance (Normal a, Normal b, Normal c) => Normal (a, b, c)
	{-# GHC_PRAGMA _M_ Norm {-dfun-} _A_ 4 _U_ 222 _N_ _S_ "SSSU(LLL)" _N_ _N_ #-}
instance Normal (a -> b)
	{-# GHC_PRAGMA _M_ Norm {-dfun-} _A_ 1 _N_ _N_ _N_ _F_ _IF_ARGS_ 2 1 X 1 _/\_ u0 u1 -> \ (u2 :: u0 -> u1) -> _!_ True [] [] _N_ #-}
instance Normal Bool
	{-# GHC_PRAGMA _M_ Norm {-dfun-} _A_ 1 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _CONSTM_ Normal normal (Bool) _N_
	 normal = _A_ 1 _U_ 1 _N_ _S_ "E" _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Bool) -> case u0 of { _ALG_ False  -> _!_ True [] []; True  -> _!_ True [] []; _NO_DEFLT_ } _N_ #-}
instance Normal Float
	{-# GHC_PRAGMA _M_ Norm {-dfun-} _A_ 1 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _CONSTM_ Normal normal (Float) _N_
	 normal = _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 0 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 1 \ (u0 :: Float#) -> _!_ True [] [] _N_} _F_ _IF_ARGS_ 0 1 C 2 \ (u0 :: Float) -> case u0 of { _ALG_ F# (u1 :: Float#) -> _!_ True [] []; _NO_DEFLT_ } _N_ #-}
instance Normal Int
	{-# GHC_PRAGMA _M_ Norm {-dfun-} _A_ 1 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _CONSTM_ Normal normal (Int) _N_
	 normal = _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 0 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 1 \ (u0 :: Int#) -> _!_ True [] [] _N_} _F_ _IF_ARGS_ 0 1 C 2 \ (u0 :: Int) -> case u0 of { _ALG_ I# (u1 :: Int#) -> _!_ True [] []; _NO_DEFLT_ } _N_ #-}
instance Normal a => Normal [a]
	{-# GHC_PRAGMA _M_ Norm {-dfun-} _A_ 2 _U_ 2 _N_ _S_ "LS" _N_ _N_ #-}

