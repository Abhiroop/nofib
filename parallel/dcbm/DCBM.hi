{-# GHC_PRAGMA INTERFACE VERSION 5 #-}
interface DCBM where
import Types(Dbt, Msgt, Tree)
acct :: (Msgt, a) -> Int
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(SA)" {_A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 1 1 C 4 _/\_ u0 -> \ (u1 :: Msgt) -> case u1 of { _ALG_ _ORIG_ Types Ok (u2 :: Int) -> u2; _ORIG_ Types Error (u3 :: Int) -> u3; _NO_DEFLT_ } _N_} _F_ _IF_ARGS_ 1 1 C 5 _/\_ u0 -> \ (u1 :: (Msgt, u0)) -> case u1 of { _ALG_ _TUP_2 (u2 :: Msgt) (u3 :: u0) -> case u2 of { _ALG_ _ORIG_ Types Ok (u4 :: Int) -> u4; _ORIG_ Types Error (u5 :: Int) -> u5; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ #-}
build_bra_tree :: Int -> Int -> Tree
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
build_tel_tree :: Int -> Int -> Int -> Tree
	{-# GHC_PRAGMA _A_ 3 _U_ 112 _N_ _S_ "U(P)U(P)L" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
builddb :: Int -> Int -> Dbt
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _N_ _N_ _N_ #-}
buildtree :: Int -> Int -> Int -> Int -> Tree
	{-# GHC_PRAGMA _A_ 4 _U_ 1121 _N_ _S_ "U(P)U(P)LU(P)" {_A_ 4 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
checksum :: [Msgt] -> Int
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
dctrans :: Int -> Int -> Int -> Int -> Dbt -> (Msgt, Dbt)
	{-# GHC_PRAGMA _A_ 5 _U_ 22221 _N_ _N_ _N_ _N_ #-}
isok :: (Msgt, a) -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(SA)" {_A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 1 1 C 4 _/\_ u0 -> \ (u1 :: Msgt) -> case u1 of { _ALG_ _ORIG_ Types Ok (u2 :: Int) -> _!_ True [] []; _ORIG_ Types Error (u3 :: Int) -> _!_ False [] []; _NO_DEFLT_ } _N_} _F_ _IF_ARGS_ 1 1 C 5 _/\_ u0 -> \ (u1 :: (Msgt, u0)) -> case u1 of { _ALG_ _TUP_2 (u2 :: Msgt) (u3 :: u0) -> case u2 of { _ALG_ _ORIG_ Types Ok (u4 :: Int) -> _!_ True [] []; _ORIG_ Types Error (u5 :: Int) -> _!_ False [] []; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ #-}
manager :: Dbt -> [Dbt -> (Msgt, Dbt)] -> [Msgt]
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ #-}
randtxs :: Int -> Int -> [Dbt -> (Msgt, Dbt)]
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _S_ "U(P)L" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
replace :: Int -> Int -> Tree -> (Msgt, Tree)
	{-# GHC_PRAGMA _A_ 3 _U_ 122 _N_ _S_ "U(P)LS" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
stoi :: [Char] -> Int
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}

