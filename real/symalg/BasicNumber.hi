{-# GHC_PRAGMA INTERFACE VERSION 5 #-}
interface BasicNumber where
import PreludeRatio(Ratio(..))
import RealM(RealT)
data BasicNumber   = BasIntegerC Integer | BasRationalC (Ratio Integer) | BasRealC RealT
data RealT 
makeRational :: BasicNumber -> BasicNumber
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
makeReal :: BasicNumber -> BasicNumber
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
instance Enum BasicNumber
	{-# GHC_PRAGMA _M_ BasicNumber {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 6 _!_ _TUP_5 [{{Ord BasicNumber}}, (BasicNumber -> [BasicNumber]), (BasicNumber -> BasicNumber -> [BasicNumber]), (BasicNumber -> BasicNumber -> [BasicNumber]), (BasicNumber -> BasicNumber -> BasicNumber -> [BasicNumber])] [_DFUN_ Ord (BasicNumber), _CONSTM_ Enum enumFrom (BasicNumber), _CONSTM_ Enum enumFromThen (BasicNumber), _CONSTM_ Enum enumFromTo (BasicNumber), _CONSTM_ Enum enumFromThenTo (BasicNumber)] _N_
	 enumFrom = _A_ 1 _U_ 2 _N_ _N_ _N_ _N_,
	 enumFromThen = _A_ 2 _U_ 22 _N_ _N_ _N_ _N_,
	 enumFromTo = _A_ 2 _U_ 22 _N_ _N_ _N_ _N_,
	 enumFromThenTo = _A_ 3 _U_ 222 _N_ _N_ _N_ _N_ #-}
instance Eq BasicNumber
	{-# GHC_PRAGMA _M_ BasicNumber {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(BasicNumber -> BasicNumber -> Bool), (BasicNumber -> BasicNumber -> Bool)] [_CONSTM_ Eq (==) (BasicNumber), _CONSTM_ Eq (/=) (BasicNumber)] _N_
	 (==) = _A_ 2 _U_ 22 _N_ _S_ "SS" _N_ _N_,
	 (/=) = _A_ 2 _U_ 22 _N_ _N_ _N_ _N_ #-}
instance Floating BasicNumber
	{-# GHC_PRAGMA _M_ BasicNumber {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 20 _!_ _TUP_19 [{{Fractional BasicNumber}}, BasicNumber, (BasicNumber -> BasicNumber), (BasicNumber -> BasicNumber), (BasicNumber -> BasicNumber), (BasicNumber -> BasicNumber -> BasicNumber), (BasicNumber -> BasicNumber -> BasicNumber), (BasicNumber -> BasicNumber), (BasicNumber -> BasicNumber), (BasicNumber -> BasicNumber), (BasicNumber -> BasicNumber), (BasicNumber -> BasicNumber), (BasicNumber -> BasicNumber), (BasicNumber -> BasicNumber), (BasicNumber -> BasicNumber), (BasicNumber -> BasicNumber), (BasicNumber -> BasicNumber), (BasicNumber -> BasicNumber), (BasicNumber -> BasicNumber)] [_DFUN_ Fractional (BasicNumber), _CONSTM_ Floating pi (BasicNumber), _CONSTM_ Floating exp (BasicNumber), _CONSTM_ Floating log (BasicNumber), _CONSTM_ Floating sqrt (BasicNumber), _CONSTM_ Floating (**) (BasicNumber), _CONSTM_ Floating logBase (BasicNumber), _CONSTM_ Floating sin (BasicNumber), _CONSTM_ Floating cos (BasicNumber), _CONSTM_ Floating tan (BasicNumber), _CONSTM_ Floating asin (BasicNumber), _CONSTM_ Floating acos (BasicNumber), _CONSTM_ Floating atan (BasicNumber), _CONSTM_ Floating sinh (BasicNumber), _CONSTM_ Floating cosh (BasicNumber), _CONSTM_ Floating tanh (BasicNumber), _CONSTM_ Floating asinh (BasicNumber), _CONSTM_ Floating acosh (BasicNumber), _CONSTM_ Floating atanh (BasicNumber)] _N_
	 pi = _A_ 0 _N_ _N_ _S_ _!_ _F_ _IF_ARGS_ 0 0 X 2 _APP_  _TYAPP_  error { BasicNumber } [ _NOREP_S_ "pi : Not yet implemented" ] _N_,
	 exp = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: BasicNumber) -> _APP_  _TYAPP_  error { (BasicNumber -> BasicNumber) } [ _NOREP_S_ "exp : Not yet implemented", u0 ] _N_,
	 log = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: BasicNumber) -> _APP_  _TYAPP_  error { (BasicNumber -> BasicNumber) } [ _NOREP_S_ "log : Not yet implemented", u0 ] _N_,
	 sqrt = _A_ 1 _U_ 1 _N_ _N_ _N_ _N_,
	 (**) = _A_ 2 _U_ 22 _N_ _N_ _N_ _N_,
	 logBase = _A_ 2 _U_ 22 _N_ _N_ _N_ _N_,
	 sin = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: BasicNumber) -> _APP_  _TYAPP_  error { (BasicNumber -> BasicNumber) } [ _NOREP_S_ "sin : Not yet implemented", u0 ] _N_,
	 cos = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: BasicNumber) -> _APP_  _TYAPP_  error { (BasicNumber -> BasicNumber) } [ _NOREP_S_ "cos : Not yet implemented", u0 ] _N_,
	 tan = _A_ 1 _U_ 2 _N_ _N_ _N_ _N_,
	 asin = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: BasicNumber) -> _APP_  _TYAPP_  error { (BasicNumber -> BasicNumber) } [ _NOREP_S_ "asin : Not yet implemented", u0 ] _N_,
	 acos = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: BasicNumber) -> _APP_  _TYAPP_  error { (BasicNumber -> BasicNumber) } [ _NOREP_S_ "acos : Not yet implemented", u0 ] _N_,
	 atan = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: BasicNumber) -> _APP_  _TYAPP_  error { (BasicNumber -> BasicNumber) } [ _NOREP_S_ "atan : Not yet implemented", u0 ] _N_,
	 sinh = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: BasicNumber) -> _APP_  _TYAPP_  error { (BasicNumber -> BasicNumber) } [ _NOREP_S_ "sinh : Not yet implemented", u0 ] _N_,
	 cosh = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: BasicNumber) -> _APP_  _TYAPP_  error { (BasicNumber -> BasicNumber) } [ _NOREP_S_ "cosh : Not yet implemented", u0 ] _N_,
	 tanh = _A_ 1 _U_ 2 _N_ _N_ _N_ _N_,
	 asinh = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: BasicNumber) -> _APP_  _TYAPP_  error { (BasicNumber -> BasicNumber) } [ _NOREP_S_ "asinh : Not yet implemented", u0 ] _N_,
	 acosh = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: BasicNumber) -> _APP_  _TYAPP_  error { (BasicNumber -> BasicNumber) } [ _NOREP_S_ "acosh : Not yet implemented", u0 ] _N_,
	 atanh = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: BasicNumber) -> _APP_  _TYAPP_  error { (BasicNumber -> BasicNumber) } [ _NOREP_S_ "atanh : Not yet implemented", u0 ] _N_ #-}
instance Fractional BasicNumber
	{-# GHC_PRAGMA _M_ BasicNumber {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 5 _!_ _TUP_4 [{{Num BasicNumber}}, (BasicNumber -> BasicNumber -> BasicNumber), (BasicNumber -> BasicNumber), (Ratio Integer -> BasicNumber)] [_DFUN_ Num (BasicNumber), _CONSTM_ Fractional (/) (BasicNumber), _CONSTM_ Fractional recip (BasicNumber), _CONSTM_ Fractional fromRational (BasicNumber)] _N_
	 (/) = _A_ 2 _U_ 22 _N_ _S_ "SL" _N_ _N_,
	 recip = _A_ 0 _U_ 2 _N_ _N_ _N_ _N_,
	 fromRational = _A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 2 \ (u0 :: Ratio Integer) -> _!_ _ORIG_ BasicNumber BasRationalC [] [u0] _N_ #-}
instance Num BasicNumber
	{-# GHC_PRAGMA _M_ BasicNumber {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 11 _!_ _TUP_10 [{{Eq BasicNumber}}, {{Text BasicNumber}}, (BasicNumber -> BasicNumber -> BasicNumber), (BasicNumber -> BasicNumber -> BasicNumber), (BasicNumber -> BasicNumber -> BasicNumber), (BasicNumber -> BasicNumber), (BasicNumber -> BasicNumber), (BasicNumber -> BasicNumber), (Integer -> BasicNumber), (Int -> BasicNumber)] [_DFUN_ Eq (BasicNumber), _DFUN_ Text (BasicNumber), _CONSTM_ Num (+) (BasicNumber), _CONSTM_ Num (-) (BasicNumber), _CONSTM_ Num (*) (BasicNumber), _CONSTM_ Num negate (BasicNumber), _CONSTM_ Num abs (BasicNumber), _CONSTM_ Num signum (BasicNumber), _CONSTM_ Num fromInteger (BasicNumber), _CONSTM_ Num fromInt (BasicNumber)] _N_
	 (+) = _A_ 2 _U_ 22 _N_ _S_ "SL" _N_ _N_,
	 (-) = _A_ 2 _U_ 22 _N_ _S_ "SL" _N_ _N_,
	 (*) = _A_ 2 _U_ 22 _N_ _S_ "SL" _N_ _N_,
	 negate = _A_ 1 _U_ 2 _N_ _N_ _N_ _N_,
	 abs = _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_,
	 signum = _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_,
	 fromInteger = _A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 2 \ (u0 :: Integer) -> _!_ _ORIG_ BasicNumber BasIntegerC [] [u0] _N_,
	 fromInt = _A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 0 1 C 5 \ (u0 :: Int) -> let {(u2 :: Integer) = case u0 of { _ALG_ I# (u1 :: Int#) -> _#_ int2Integer# [] [u1]; _NO_DEFLT_ }} in _!_ _ORIG_ BasicNumber BasIntegerC [] [u2] _N_ #-}
instance Ord BasicNumber
	{-# GHC_PRAGMA _M_ BasicNumber {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 9 _!_ _TUP_8 [{{Eq BasicNumber}}, (BasicNumber -> BasicNumber -> Bool), (BasicNumber -> BasicNumber -> Bool), (BasicNumber -> BasicNumber -> Bool), (BasicNumber -> BasicNumber -> Bool), (BasicNumber -> BasicNumber -> BasicNumber), (BasicNumber -> BasicNumber -> BasicNumber), (BasicNumber -> BasicNumber -> _CMP_TAG)] [_DFUN_ Eq (BasicNumber), _CONSTM_ Ord (<) (BasicNumber), _CONSTM_ Ord (<=) (BasicNumber), _CONSTM_ Ord (>=) (BasicNumber), _CONSTM_ Ord (>) (BasicNumber), _CONSTM_ Ord max (BasicNumber), _CONSTM_ Ord min (BasicNumber), _CONSTM_ Ord _tagCmp (BasicNumber)] _N_
	 (<) = _A_ 2 _U_ 22 _N_ _S_ "SS" _N_ _N_,
	 (<=) = _A_ 2 _U_ 22 _N_ _S_ "SS" _N_ _N_,
	 (>=) = _A_ 2 _U_ 22 _N_ _S_ "SS" _F_ _IF_ARGS_ 0 2 XX 3 \ (u0 :: BasicNumber) (u1 :: BasicNumber) -> _APP_  _CONSTM_ Ord (<=) (BasicNumber) [ u1, u0 ] _N_,
	 (>) = _A_ 2 _U_ 22 _N_ _S_ "SS" _F_ _IF_ARGS_ 0 2 XX 3 \ (u0 :: BasicNumber) (u1 :: BasicNumber) -> _APP_  _CONSTM_ Ord (<) (BasicNumber) [ u1, u0 ] _N_,
	 max = _A_ 2 _U_ 22 _N_ _N_ _N_ _N_,
	 min = _A_ 2 _U_ 22 _N_ _N_ _N_ _N_,
	 _tagCmp = _A_ 2 _U_ 22 _N_ _N_ _N_ _N_ #-}
instance Real BasicNumber
	{-# GHC_PRAGMA _M_ BasicNumber {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 4 _!_ _TUP_3 [{{Num BasicNumber}}, {{Enum BasicNumber}}, (BasicNumber -> Ratio Integer)] [_DFUN_ Num (BasicNumber), _DFUN_ Enum (BasicNumber), _CONSTM_ Real toRational (BasicNumber)] _N_
	 toRational = _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
instance Text BasicNumber
	{-# GHC_PRAGMA _M_ BasicNumber {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 5 _!_ _TUP_4 [(Int -> [Char] -> [(BasicNumber, [Char])]), (Int -> BasicNumber -> [Char] -> [Char]), ([Char] -> [([BasicNumber], [Char])]), ([BasicNumber] -> [Char] -> [Char])] [_CONSTM_ Text readsPrec (BasicNumber), _CONSTM_ Text showsPrec (BasicNumber), _CONSTM_ Text readList (BasicNumber), _CONSTM_ Text showList (BasicNumber)] _N_
	 readsPrec = _A_ 2 _U_ 02 _N_ _S_ "AS" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_,
	 showsPrec = _A_ 3 _U_ 012 _N_ _S_ "ASL" {_A_ 2 _U_ 12 _N_ _N_ _N_ _N_} _N_ _N_,
	 readList = _A_ 0 _U_ 2 _N_ _N_ _N_ _N_,
	 showList = _A_ 0 _U_ 12 _N_ _N_ _N_ _N_ #-}

