{-# GHC_PRAGMA INTERFACE VERSION 5 #-}
interface Lexer where
data Lexeme   = Ide [Char] | Evar [Char] | Op [Char] | Num [Char] | Lparen | Rparen | Comma
lexer :: [Char] -> ([Lexeme], Bool)
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _S_ "S" _N_ _N_ #-}
instance Eq Lexeme
	{-# GHC_PRAGMA _M_ Lexer {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Lexeme -> Lexeme -> Bool), (Lexeme -> Lexeme -> Bool)] [_CONSTM_ Eq (==) (Lexeme), _CONSTM_ Eq (/=) (Lexeme)] _N_
	 (==) = _A_ 2 _U_ 22 _N_ _S_ "SS" _N_ _N_,
	 (/=) = _A_ 2 _U_ 22 _N_ _S_ "SS" _N_ _N_ #-}

