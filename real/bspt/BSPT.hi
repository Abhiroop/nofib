{-# GHC_PRAGMA INTERFACE VERSION 5 #-}
interface BSPT where
import Euclid(Face, Faces(..), Line, Point)
import EuclidGMS(Region)
import Rationals(Rationals)
data BSPT   = Cell Status Region Rationals | BSP Face ([Face], Region) BSPT BSPT
data Face 	{-# GHC_PRAGMA Fc (Point, Point) Line #-}
type Faces = [Face]
data Line 	{-# GHC_PRAGMA Ln Rationals Rationals Rationals #-}
data Point 	{-# GHC_PRAGMA Pt Rationals Rationals #-}
data Region 	{-# GHC_PRAGMA Rg [Face] #-}
data Status   = In | Out | On
area :: BSPT -> Rationals
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _N_ _N_ _N_ #-}
bsp' :: Face -> ([Face], Region) -> BSPT -> BSPT -> BSPT
	{-# GHC_PRAGMA _A_ 4 _U_ 2122 _N_ _S_ "LU(LL)SL" {_A_ 5 _U_ 22222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
bsp'' :: Face -> ([Face], Region) -> BSPT -> BSPT -> BSPT
	{-# GHC_PRAGMA _A_ 4 _U_ 2122 _N_ _S_ "LU(LL)LL" {_A_ 5 _U_ 21222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
buildBSPT :: [Face] -> BSPT
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ #-}
classifyPoint :: Point -> BSPT -> Status
	{-# GHC_PRAGMA _A_ 1 _U_ 21 _N_ _N_ _N_ _N_ #-}
countLeaves :: BSPT -> Int
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _N_ _N_ _N_ #-}
foldBSPT :: (Status -> Region -> Rationals -> a) -> (Face -> ([Face], Region) -> a -> a -> a) -> BSPT -> a
	{-# GHC_PRAGMA _A_ 3 _U_ 221 _N_ _S_ "LLS" _N_ _N_ #-}
mkCell :: Status -> Region -> BSPT
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _N_ _N_ _N_ #-}
partFaces :: Line -> [Face] -> ([Face], [Face], [Face])
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _S_ "LS" _N_ _N_ #-}
scanLine :: BSPT -> Face -> [Face]
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _N_ _N_ _N_ #-}
instance Eq Status
	{-# GHC_PRAGMA _M_ BSPT {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Status -> Status -> Bool), (Status -> Status -> Bool)] [_CONSTM_ Eq (==) (Status), _CONSTM_ Eq (/=) (Status)] _N_
	 (==) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_,
	 (/=) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_ #-}
instance Eq Face
	{-# GHC_PRAGMA _M_ Euclid {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Face -> Face -> Bool), (Face -> Face -> Bool)] [_CONSTM_ Eq (==) (Face), _CONSTM_ Eq (/=) (Face)] _N_
	 (==) = _A_ 2 _U_ 11 _N_ _S_ "U(LL)U(LL)" {_A_ 4 _U_ 2121 _N_ _N_ _N_ _N_} _N_ _N_,
	 (/=) = _A_ 2 _U_ 11 _N_ _S_ "U(LL)U(LL)" {_A_ 4 _U_ 2121 _N_ _N_ _N_ _N_} _N_ _N_ #-}
instance Eq Line
	{-# GHC_PRAGMA _M_ Euclid {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Line -> Line -> Bool), (Line -> Line -> Bool)] [_CONSTM_ Eq (==) (Line), _CONSTM_ Eq (/=) (Line)] _N_
	 (==) = _A_ 2 _U_ 11 _N_ _S_ "U(U(U(P)L)LL)U(U(U(P)L)LL)" {_A_ 5 _U_ 21111 _N_ _N_ _N_ _N_} _N_ _N_,
	 (/=) = _A_ 2 _U_ 11 _N_ _S_ "U(U(U(P)L)LL)U(U(U(P)L)LL)" {_A_ 5 _U_ 21111 _N_ _N_ _N_ _N_} _N_ _N_ #-}
instance Eq Point
	{-# GHC_PRAGMA _M_ Euclid {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Point -> Point -> Bool), (Point -> Point -> Bool)] [_CONSTM_ Eq (==) (Point), _CONSTM_ Eq (/=) (Point)] _N_
	 (==) = _A_ 2 _U_ 11 _N_ _S_ "U(U(U(P)L)L)U(U(U(P)L)L)" {_A_ 5 _U_ 21111 _N_ _N_ _N_ _N_} _N_ _N_,
	 (/=) = _A_ 2 _U_ 11 _N_ _S_ "U(U(U(P)L)L)U(U(U(P)L)L)" {_A_ 5 _U_ 21111 _N_ _N_ _N_ _N_} _N_ _N_ #-}
instance Text Status
	{-# GHC_PRAGMA _M_ BSPT {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 5 _!_ _TUP_4 [(Int -> [Char] -> [(Status, [Char])]), (Int -> Status -> [Char] -> [Char]), ([Char] -> [([Status], [Char])]), ([Status] -> [Char] -> [Char])] [_CONSTM_ Text readsPrec (Status), _CONSTM_ Text showsPrec (Status), _CONSTM_ Text readList (Status), _CONSTM_ Text showList (Status)] _N_
	 readsPrec = _A_ 1 _U_ 12 _N_ _S_ "U(P)" {_A_ 1 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_,
	 showsPrec = _A_ 2 _U_ 112 _N_ _S_ "LE" _N_ _N_,
	 readList = _A_ 0 _U_ 2 _N_ _N_ _N_ _N_,
	 showList = _A_ 0 _U_ 12 _N_ _N_ _N_ _N_ #-}
instance Text Face
	{-# GHC_PRAGMA _M_ Euclid {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 5 _!_ _TUP_4 [(Int -> [Char] -> [(Face, [Char])]), (Int -> Face -> [Char] -> [Char]), ([Char] -> [([Face], [Char])]), ([Face] -> [Char] -> [Char])] [_CONSTM_ Text readsPrec (Face), _CONSTM_ Text showsPrec (Face), _CONSTM_ Text readList (Face), _CONSTM_ Text showList (Face)] _N_
	 readsPrec = _A_ 1 _U_ 12 _N_ _S_ "U(P)" {_A_ 1 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_,
	 showsPrec = _A_ 2 _U_ 112 _N_ _S_ "LU(LL)" {_A_ 3 _U_ 1222 _N_ _N_ _N_ _N_} _N_ _N_,
	 readList = _A_ 0 _U_ 2 _N_ _N_ _N_ _N_,
	 showList = _A_ 0 _U_ 12 _N_ _N_ _N_ _N_ #-}
instance Text Line
	{-# GHC_PRAGMA _M_ Euclid {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 5 _!_ _TUP_4 [(Int -> [Char] -> [(Line, [Char])]), (Int -> Line -> [Char] -> [Char]), ([Char] -> [([Line], [Char])]), ([Line] -> [Char] -> [Char])] [_CONSTM_ Text readsPrec (Line), _CONSTM_ Text showsPrec (Line), _CONSTM_ Text readList (Line), _CONSTM_ Text showList (Line)] _N_
	 readsPrec = _A_ 1 _U_ 12 _N_ _S_ "U(P)" {_A_ 1 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_,
	 showsPrec = _A_ 2 _U_ 112 _N_ _S_ "LU(LLL)" {_A_ 4 _U_ 12222 _N_ _N_ _N_ _N_} _N_ _N_,
	 readList = _A_ 0 _U_ 2 _N_ _N_ _N_ _N_,
	 showList = _A_ 0 _U_ 12 _N_ _N_ _N_ _N_ #-}
instance Text Point
	{-# GHC_PRAGMA _M_ Euclid {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 5 _!_ _TUP_4 [(Int -> [Char] -> [(Point, [Char])]), (Int -> Point -> [Char] -> [Char]), ([Char] -> [([Point], [Char])]), ([Point] -> [Char] -> [Char])] [_CONSTM_ Text readsPrec (Point), _CONSTM_ Text showsPrec (Point), _CONSTM_ Text readList (Point), _CONSTM_ Text showList (Point)] _N_
	 readsPrec = _A_ 1 _U_ 12 _N_ _S_ "U(P)" {_A_ 1 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_,
	 showsPrec = _A_ 2 _U_ 112 _N_ _S_ "LU(LL)" {_A_ 3 _U_ 1222 _N_ _N_ _N_ _N_} _N_ _N_,
	 readList = _A_ 0 _U_ 2 _N_ _N_ _N_ _N_,
	 showList = _A_ 0 _U_ 12 _N_ _N_ _N_ _N_ #-}

