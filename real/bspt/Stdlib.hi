{-# GHC_PRAGMA INTERFACE VERSION 5 #-}
interface Stdlib where
all_YORK :: [Bool] -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
between :: (Ord a, Num a) => a -> a -> a -> Bool
	{-# GHC_PRAGMA _A_ 5 _U_ 11222 _N_ _S_ "U(AASAAAAA)LLLL" {_A_ 5 _U_ 21222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
const3 :: d -> a -> b -> c -> d
	{-# GHC_PRAGMA _A_ 4 _U_ 1000 _N_ _S_ "SAAA" {_A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 4 1 X 1 _/\_ u0 u1 u2 u3 -> \ (u4 :: u3) -> u4 _N_} _F_ _IF_ARGS_ 4 4 XXXX 1 _/\_ u0 u1 u2 u3 -> \ (u4 :: u3) (u5 :: u0) (u6 :: u1) (u7 :: u2) -> u4 _N_ #-}
map2 :: (a -> b -> c) -> [a] -> [b] -> [c]
	{-# GHC_PRAGMA _A_ 3 _U_ 211 _N_ _S_ "LSL" _N_ _N_ #-}
mapcat :: (a -> [b]) -> [a] -> [b]
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ #-}
mappair :: (a -> b) -> (a, a) -> (b, b)
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LU(LL)" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
middle :: Int -> Int -> Int
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 4 \ (u0 :: Int#) (u1 :: Int#) -> case _#_ plusInt# [] [u0, u1] of { _PRIM_ (u2 :: Int#) -> _APP_  _WRKR_ _CONSTM_ Integral div (Int) [ u2, 2# ] } _N_} _F_ _IF_ARGS_ 0 2 CC 6 \ (u0 :: Int) (u1 :: Int) -> case u0 of { _ALG_ I# (u2 :: Int#) -> case u1 of { _ALG_ I# (u3 :: Int#) -> case _#_ plusInt# [] [u2, u3] of { _PRIM_ (u4 :: Int#) -> _APP_  _WRKR_ _CONSTM_ Integral div (Int) [ u4, 2# ] }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ #-}
mkset :: Eq a => [a] -> [a]
	{-# GHC_PRAGMA _A_ 1 _U_ 11 _N_ _N_ _N_ _N_ #-}
numval :: [Char] -> Int
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _S_ "S" _N_ _N_ #-}
pair :: a -> b -> (a, b)
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 2 2 XX 3 _/\_ u0 u1 -> \ (u2 :: u0) (u3 :: u1) -> _!_ _TUP_2 [u0, u1] [u2, u3] _N_ #-}
sequence :: [[Char]] -> [Char]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
splitAt_YORK :: Eq a => a -> [a] -> ([a], [a])
	{-# GHC_PRAGMA _A_ 1 _U_ 122 _N_ _N_ _N_ _N_ #-}
toNum :: Char -> Int
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 4 \ (u0 :: Char#) -> case _#_ ord# [] [u0] of { _PRIM_ (u1 :: Int#) -> case _#_ minusInt# [] [u1, 48#] of { _PRIM_ (u2 :: Int#) -> _!_ I# [] [u2] } } _N_} _F_ _IF_ARGS_ 0 1 C 5 \ (u0 :: Char) -> case u0 of { _ALG_ C# (u1 :: Char#) -> case _#_ ord# [] [u1] of { _PRIM_ (u2 :: Int#) -> case _#_ minusInt# [] [u2, 48#] of { _PRIM_ (u3 :: Int#) -> _!_ I# [] [u3] } }; _NO_DEFLT_ } _N_ #-}

