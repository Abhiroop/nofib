{-# GHC_PRAGMA INTERFACE VERSION 5 #-}
interface Environment where
import FiniteMap(FM)
import Type(MonoType, PolyType)
data Env 	{-# GHC_PRAGMA MkEnv (FM [Char] PolyType) #-}
domEnv :: Env -> [[Char]]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(U(S))" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ #-}
emptyEnv :: Env
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _N_ _N_ _N_ #-}
extendGlobal :: Env -> [Char] -> PolyType -> Env
	{-# GHC_PRAGMA _A_ 3 _U_ 122 _N_ _N_ _N_ _N_ #-}
extendLocal :: Env -> [Char] -> MonoType -> Env
	{-# GHC_PRAGMA _A_ 3 _U_ 122 _N_ _N_ _N_ _N_ #-}
freeTVarEnv :: Env -> [[Char]]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(U(S))" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ #-}
lookupEnv :: Env -> [Char] -> PolyType
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _N_ _N_ _N_ #-}
makeEnv :: [([Char], PolyType)] -> Env
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ #-}
unmakeEnv :: Env -> [([Char], PolyType)]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(U(S))" {_A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 1 \ (u0 :: [([Char], PolyType)]) -> u0 _N_} _F_ _IF_ARGS_ 0 1 C 3 \ (u0 :: Env) -> case u0 of { _ALG_ _ORIG_ Environment MkEnv (u1 :: FM [Char] PolyType) -> case u1 of { _ALG_ _ORIG_ FiniteMap MkFM (u2 :: [([Char], PolyType)]) -> u2; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ #-}
instance Text Env
	{-# GHC_PRAGMA _M_ Environment {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 5 _!_ _TUP_4 [(Int -> [Char] -> [(Env, [Char])]), (Int -> Env -> [Char] -> [Char]), ([Char] -> [([Env], [Char])]), ([Env] -> [Char] -> [Char])] [_CONSTM_ Text readsPrec (Env), _CONSTM_ Text showsPrec (Env), _CONSTM_ Text readList (Env), _CONSTM_ Text showList (Env)] _N_
	 readsPrec = _A_ 1 _U_ 02 _N_ _S_ "A" {_A_ 0 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_,
	 showsPrec = _A_ 3 _U_ 012 _N_ _S_ "ALL" {_A_ 2 _U_ 12 _N_ _N_ _N_ _N_} _N_ _N_,
	 readList = _A_ 0 _U_ 2 _N_ _N_ _N_ _N_,
	 showList = _A_ 0 _U_ 12 _N_ _N_ _N_ _N_ #-}

