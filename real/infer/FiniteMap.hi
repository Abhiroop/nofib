{-# GHC_PRAGMA INTERFACE VERSION 5 #-}
interface FiniteMap where
data FM a b 	{-# GHC_PRAGMA MkFM [(a, b)] #-}
disjointFM :: Eq a => FM a b -> FM a b -> Bool
	{-# GHC_PRAGMA _A_ 3 _U_ 111 _N_ _S_ "LU(S)L" {_A_ 3 _U_ 111 _N_ _N_ _N_ _N_} _N_ _N_ #-}
domFM :: FM b a -> [b]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(S)" {_A_ 1 _U_ 1 _N_ _N_ _N_ _N_} _N_ _N_ #-}
emptyFM :: FM a b
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _N_ _N_ _N_ #-}
extendFM :: FM a b -> a -> b -> FM a b
	{-# GHC_PRAGMA _A_ 3 _U_ 122 _N_ _S_ "U(L)LL" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
lookupElseFM :: Eq a => b -> FM a b -> a -> b
	{-# GHC_PRAGMA _A_ 4 _U_ 1212 _N_ _S_ "LLU(S)L" {_A_ 4 _U_ 1212 _N_ _N_ _N_ _N_} _N_ _N_ #-}
lookupFM :: Eq a => FM a b -> a -> b
	{-# GHC_PRAGMA _A_ 3 _U_ 112 _N_ _N_ _N_ _N_ #-}
makeFM :: [(a, b)] -> FM a b
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 2 1 X 2 _/\_ u0 u1 -> \ (u2 :: [(u0, u1)]) -> _!_ _ORIG_ FiniteMap MkFM [u0, u1] [u2] _N_ #-}
mapFM :: (a -> c) -> FM b a -> FM b c
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LU(L)" {_A_ 2 _U_ 21 _N_ _N_ _N_ _N_} _N_ _N_ #-}
plusFM :: Eq a => FM a b -> FM a b -> FM a b
	{-# GHC_PRAGMA _A_ 3 _U_ 112 _N_ _N_ _N_ _N_ #-}
ranFM :: FM a b -> [b]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(S)" {_A_ 1 _U_ 1 _N_ _N_ _N_ _N_} _N_ _N_ #-}
thenFM :: FM a b -> FM a b -> FM a b
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "U(L)U(L)" {_A_ 2 _U_ 21 _N_ _N_ _N_ _N_} _N_ _N_ #-}
unitFM :: a -> b -> FM a b
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _N_ _N_ _N_ #-}
unmakeFM :: FM a b -> [(a, b)]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(S)" {_A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 2 1 X 1 _/\_ u0 u1 -> \ (u2 :: [(u0, u1)]) -> u2 _N_} _F_ _IF_ARGS_ 2 1 C 2 _/\_ u0 u1 -> \ (u2 :: FM u0 u1) -> case u2 of { _ALG_ _ORIG_ FiniteMap MkFM (u3 :: [(u0, u1)]) -> u3; _NO_DEFLT_ } _N_ #-}

