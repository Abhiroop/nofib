{-# GHC_PRAGMA INTERFACE VERSION 5 #-}
interface Parse where
infixr 1 `elseP`
infixr 3 `filterP`
infixr 3 `guardP`
infix  2 `eachP`
infix  2 `thenP`
type Parse a b = a -> [(b, a)]
type Parses a = [Char] -> [(a, [Char])]
alphaP :: [Char] -> [(Char, [Char])]
	{-# GHC_PRAGMA _A_ 0 _U_ 1 _N_ _N_ _N_ _N_ #-}
alphanumP :: [Char] -> [(Char, [Char])]
	{-# GHC_PRAGMA _A_ 0 _U_ 1 _N_ _N_ _N_ _N_ #-}
asciiP :: [Char] -> [(Char, [Char])]
	{-# GHC_PRAGMA _A_ 0 _U_ 1 _N_ _N_ _N_ _N_ #-}
consP :: (a -> [(b, a)]) -> (a -> [([b], a)]) -> a -> [([b], a)]
	{-# GHC_PRAGMA _A_ 2 _U_ 122 _N_ _S_ "SL" _N_ _N_ #-}
controlP :: [Char] -> [(Char, [Char])]
	{-# GHC_PRAGMA _A_ 0 _U_ 1 _N_ _N_ _N_ _N_ #-}
cutP :: (a -> [(b, a)]) -> a -> [(b, a)]
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _N_ _N_ _N_ #-}
digitP :: [Char] -> [(Char, [Char])]
	{-# GHC_PRAGMA _A_ 0 _U_ 1 _N_ _N_ _N_ _N_ #-}
eachP :: (b -> [(a, b)]) -> (a -> c) -> b -> [(c, b)]
	{-# GHC_PRAGMA _A_ 2 _U_ 122 _N_ _S_ "SL" _N_ _N_ #-}
elseP :: (a -> [(b, a)]) -> (a -> [(b, a)]) -> a -> [(b, a)]
	{-# GHC_PRAGMA _A_ 3 _U_ 112 _N_ _S_ "SLL" _N_ _N_ #-}
endP :: [a] -> [((), [a])]
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _S_ "S" _N_ _N_ #-}
exactlyP :: ([a] -> [(b, [a])]) -> [a] -> [(b, [a])]
	{-# GHC_PRAGMA _A_ 1 _U_ 12 _N_ _S_ "S" _N_ _N_ #-}
failP :: a -> [(b, a)]
	{-# GHC_PRAGMA _A_ 1 _U_ 0 _N_ _S_ "A" {_A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 2 0 X 1 _/\_ u0 u1 -> _!_ _NIL_ [(u1, u0)] [] _N_} _F_ _IF_ARGS_ 2 1 X 1 _/\_ u0 u1 -> \ (u2 :: u0) -> _!_ _NIL_ [(u1, u0)] [] _N_ #-}
filterP :: (b -> Bool) -> (a -> [(b, a)]) -> a -> [(b, a)]
	{-# GHC_PRAGMA _A_ 2 _U_ 212 _N_ _S_ "LS" _N_ _N_ #-}
guardP :: Bool -> (a -> [(b, a)]) -> a -> [(b, a)]
	{-# GHC_PRAGMA _A_ 2 _U_ 112 _N_ _S_ "EL" _F_ _IF_ARGS_ 2 2 CX 4 _/\_ u0 u1 -> \ (u2 :: Bool) (u3 :: u0 -> [(u1, u0)]) -> case u2 of { _ALG_ True  -> u3; False  -> _TYAPP_  _TYAPP_  _ORIG_ Parse failP { u0 } { u1 }; _NO_DEFLT_ } _N_ #-}
itemP :: [a] -> [(a, [a])]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _IF_ARGS_ 1 1 C 6 _/\_ u0 -> \ (u1 :: [u0]) -> case u1 of { _ALG_ _NIL_  -> _!_ _NIL_ [(u0, [u0])] []; (:) (u2 :: u0) (u3 :: [u0]) -> _APP_  _TYAPP_  _TYAPP_  _ORIG_ Parse returnP { [u0] } { u0 } [ u2, u3 ]; _NO_DEFLT_ } _N_ #-}
lexP :: [Char] -> [Char] -> [([Char], [Char])]
	{-# GHC_PRAGMA _A_ 1 _U_ 22 _N_ _S_ "S" _N_ _N_ #-}
lexactlyP :: ([Char] -> [(a, [Char])]) -> [Char] -> [(a, [Char])]
	{-# GHC_PRAGMA _A_ 1 _U_ 22 _N_ _N_ _N_ _N_ #-}
lexicalP :: ([Char] -> [(a, [Char])]) -> [Char] -> [(a, [Char])]
	{-# GHC_PRAGMA _A_ 1 _U_ 12 _N_ _S_ "S" _N_ _N_ #-}
listP :: ([Char] -> [(a, [Char])]) -> [Char] -> [([a], [Char])]
	{-# GHC_PRAGMA _A_ 1 _U_ 22 _N_ _N_ _N_ _N_ #-}
litP :: Eq a => a -> [a] -> [(a, [a])]
	{-# GHC_PRAGMA _A_ 2 _U_ 121 _N_ _N_ _N_ _SPECIALISE_ [ Char ] 1 { _A_ 1 _U_ 21 _N_ _N_ _N_ _N_ } #-}
litsP :: Eq a => [a] -> [a] -> [([a], [a])]
	{-# GHC_PRAGMA _A_ 1 _U_ 222 _N_ _N_ _N_ _SPECIALISE_ [ Char ] 1 { _A_ 1 _U_ 22 _N_ _S_ "S" _N_ _N_ } #-}
lowerP :: [Char] -> [(Char, [Char])]
	{-# GHC_PRAGMA _A_ 0 _U_ 1 _N_ _N_ _N_ _N_ #-}
parenP :: ([Char] -> [(a, [Char])]) -> [Char] -> [(a, [Char])]
	{-# GHC_PRAGMA _A_ 1 _U_ 22 _N_ _N_ _N_ _N_ #-}
plusP :: (a -> [(b, a)]) -> a -> [([b], a)]
	{-# GHC_PRAGMA _A_ 1 _U_ 22 _N_ _S_ "S" _N_ _N_ #-}
plusSepP :: [Char] -> ([Char] -> [(a, [Char])]) -> [Char] -> [([a], [Char])]
	{-# GHC_PRAGMA _A_ 2 _U_ 222 _N_ _S_ "LS" _N_ _N_ #-}
printP :: [Char] -> [(Char, [Char])]
	{-# GHC_PRAGMA _A_ 0 _U_ 1 _N_ _N_ _N_ _N_ #-}
returnP :: b -> a -> [(b, a)]
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _N_ _N_ _N_ #-}
spaceP :: [Char] -> [(Char, [Char])]
	{-# GHC_PRAGMA _A_ 0 _U_ 1 _N_ _N_ _N_ _N_ #-}
spacesP :: [Char] -> [([Char], [Char])]
	{-# GHC_PRAGMA _A_ 0 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 2 _APP_  _TYAPP_  _TYAPP_  _ORIG_ Parse starP { [Char] } { Char } [ _ORIG_ Parse spaceP ] _N_ #-}
starP :: (a -> [(b, a)]) -> a -> [([b], a)]
	{-# GHC_PRAGMA _A_ 1 _U_ 22 _N_ _N_ _N_ _N_ #-}
starSepP :: [Char] -> ([Char] -> [(a, [Char])]) -> [Char] -> [([a], [Char])]
	{-# GHC_PRAGMA _A_ 2 _U_ 222 _N_ _S_ "LS" _N_ _N_ #-}
surroundP :: [Char] -> ([Char] -> [(a, [Char])]) -> [Char] -> [Char] -> [(a, [Char])]
	{-# GHC_PRAGMA _A_ 3 _U_ 2222 _N_ _S_ "SLL" _N_ _N_ #-}
thenP :: (b -> [(a, b)]) -> (a -> b -> [(c, b)]) -> b -> [(c, b)]
	{-# GHC_PRAGMA _A_ 3 _U_ 122 _N_ _S_ "SLL" _N_ _N_ #-}
upperP :: [Char] -> [(Char, [Char])]
	{-# GHC_PRAGMA _A_ 0 _U_ 1 _N_ _N_ _N_ _N_ #-}
useP :: b -> (a -> [(b, a)]) -> a -> b
	{-# GHC_PRAGMA _A_ 3 _U_ 112 _N_ _S_ "LSL" _N_ _N_ #-}

