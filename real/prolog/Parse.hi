{-# GHC_PRAGMA INTERFACE VERSION 5 #-}
interface Parse where
infixl 5 `do`
infixr 4 `orelse`
infixr 6 `seq`
type Parser a = [Char] -> [(a, [Char])]
do :: ([Char] -> [(a, [Char])]) -> (a -> b) -> [Char] -> [(b, [Char])]
	{-# GHC_PRAGMA _A_ 3 _U_ 122 _N_ _S_ "SLL" _N_ _N_ #-}
fail :: [Char] -> [(a, [Char])]
	{-# GHC_PRAGMA _A_ 1 _U_ 0 _N_ _S_ "A" {_A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 1 0 X 1 _/\_ u0 -> _!_ _NIL_ [(u0, [Char])] [] _N_} _F_ _IF_ARGS_ 1 1 X 1 _/\_ u0 -> \ (u1 :: [Char]) -> _!_ _NIL_ [(u0, [Char])] [] _N_ #-}
just :: ([Char] -> [(a, [Char])]) -> [Char] -> [(a, [Char])]
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _S_ "SL" _N_ _N_ #-}
listOf :: ([Char] -> [(b, [Char])]) -> ([Char] -> [(a, [Char])]) -> [Char] -> [([b], [Char])]
	{-# GHC_PRAGMA _A_ 2 _U_ 222 _N_ _S_ "SL" _N_ _N_ #-}
many :: ([Char] -> [(a, [Char])]) -> [Char] -> [([a], [Char])]
	{-# GHC_PRAGMA _A_ 1 _U_ 22 _N_ _S_ "S" _N_ _N_ #-}
many1 :: ([Char] -> [(a, [Char])]) -> [Char] -> [([a], [Char])]
	{-# GHC_PRAGMA _A_ 1 _U_ 22 _N_ _S_ "S" _N_ _N_ #-}
okay :: a -> [Char] -> [(a, [Char])]
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _N_ _N_ _N_ #-}
orelse :: ([Char] -> [(a, [Char])]) -> ([Char] -> [(a, [Char])]) -> [Char] -> [(a, [Char])]
	{-# GHC_PRAGMA _A_ 3 _U_ 112 _N_ _S_ "SLL" _N_ _N_ #-}
sat :: (Char -> Bool) -> [Char] -> [(Char, [Char])]
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "LS" _N_ _N_ #-}
seq :: ([Char] -> [(a, [Char])]) -> ([Char] -> [(b, [Char])]) -> [Char] -> [((a, b), [Char])]
	{-# GHC_PRAGMA _A_ 3 _U_ 122 _N_ _S_ "SLL" _N_ _N_ #-}
sp :: ([Char] -> [(a, [Char])]) -> [Char] -> [(a, [Char])]
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "SL" _N_ _N_ #-}
sptok :: [Char] -> [Char] -> [([Char], [Char])]
	{-# GHC_PRAGMA _A_ 1 _U_ 21 _N_ _S_ "S" _N_ _N_ #-}
tok :: [Char] -> [Char] -> [([Char], [Char])]
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _S_ "SL" _N_ _N_ #-}

