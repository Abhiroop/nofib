{-# GHC_PRAGMA INTERFACE VERSION 5 #-}
interface Spark where
import GRIP(PElement)
import Parse(Parse)
data Spark   = USED | RESUMED | CREATED | LOST
sparkGraph :: [Spark] -> [PElement] -> [Char] -> [Char]
	{-# GHC_PRAGMA _A_ 3 _U_ 222 _N_ _N_ _N_ _N_ #-}
instance Eq Spark
	{-# GHC_PRAGMA _M_ Spark {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Spark -> Spark -> Bool), (Spark -> Spark -> Bool)] [_CONSTM_ Eq (==) (Spark), _CONSTM_ Eq (/=) (Spark)] _N_
	 (==) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_,
	 (/=) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_ #-}
instance Parse Spark
	{-# GHC_PRAGMA _M_ Spark {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 6 _!_ _TUP_5 [([Char] -> [Spark]), ([Char] -> Spark), ([Char] -> (Spark, [Char])), ([Char] -> (Spark, [Char])), (Spark -> Bool)] [_CONSTM_ Parse parseFile (Spark), _CONSTM_ Parse parseLine (Spark), _CONSTM_ Parse parse (Spark), _CONSTM_ Parse parseType (Spark), _CONSTM_ Parse forced (Spark)] _N_
	 parseFile = _A_ 1 _U_ 2 _N_ _S_ "S" _N_ _N_,
	 parseLine = _A_ 1 _U_ 2 _N_ _N_ _N_ _N_,
	 parse = _A_ 1 _U_ 2 _N_ _N_ _N_ _N_,
	 parseType = _A_ 1 _U_ 2 _N_ _S_ "S" _N_ _N_,
	 forced = _A_ 1 _U_ 0 _N_ _S_ "A" {_A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _!_ True [] [] _N_} _F_ _IF_ARGS_ 0 1 X 1 \ (u0 :: Spark) -> _!_ True [] [] _N_ #-}

