{-# GHC_PRAGMA INTERFACE VERSION 5 #-}
interface Graph where
import GRIP(PElement)
import PSlib(Point)
axisScale :: Int -> Int
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ #-}
axisScale' :: (Ord a, Num a) => a -> a -> a
	{-# GHC_PRAGMA _A_ 2 _U_ 1222 _N_ _S_ "U(AASAAAAA)L" {_A_ 2 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Int ] 2 { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
calibrate :: Integral a => a -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 12 _N_ _S_ "U(LU(U(AASAAAAA)AAA)AALAAAAAAA)" {_A_ 3 _U_ 1222 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Int ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
checkPEs :: [PElement] -> [PElement] -> Bool
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ #-}
cms2pts :: Int -> Int
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _N_ _N_ _N_ #-}
determineScale :: [Point] -> (Int, Int)
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _N_ _N_ _N_ #-}
dimX :: Int
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 2 _!_ I# [] [250#] _N_ #-}
dimY :: Int
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 2 _!_ I# [] [150#] _N_ #-}
dokeys :: Int -> [(Int, [Char], [Char])] -> [Char]
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _S_ "U(P)S" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
dopes :: Int -> [([Char], [Char])] -> [Char]
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _S_ "U(P)S" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
ePostscript :: (Int, Int) -> [Char] -> [Char]
	{-# GHC_PRAGMA _A_ 0 _U_ 11 _N_ _N_ _N_ _N_ #-}
gspostscript :: [Char] -> [Char]
	{-# GHC_PRAGMA _A_ 0 _U_ 2 _N_ _N_ _N_ _N_ #-}
initGraph :: [Char] -> ([PElement], [PElement]) -> (Int, Int) -> ([Char], [Char]) -> [(Int, [Char], [Char])] -> [Char]
	{-# GHC_PRAGMA _A_ 0 _U_ 22222 _N_ _N_ _N_ _N_ #-}
inv :: (Ord a, Num a) => a -> [Char]
	{-# GHC_PRAGMA _A_ 2 _U_ 112 _N_ _S_ "U(AAASAAAA)L" {_A_ 2 _U_ 112 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Int ] 2 { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
markOnX :: Int -> [Char]
	{-# GHC_PRAGMA _A_ 0 _U_ 2 _N_ _N_ _N_ _N_ #-}
markOnY :: Int -> [Char]
	{-# GHC_PRAGMA _A_ 0 _U_ 2 _N_ _N_ _N_ _N_ #-}
markXAxis :: Int -> Int -> [Char]
	{-# GHC_PRAGMA _A_ 0 _U_ 21 _N_ _N_ _N_ _N_ #-}
markYAxis :: Int -> Int -> [Char]
	{-# GHC_PRAGMA _A_ 0 _U_ 22 _N_ _N_ _N_ _N_ #-}
minandmax :: [Point] -> (Point, Point)
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
movetofloat :: (Text a, Text b) => a -> b -> [Char]
	{-# GHC_PRAGMA _A_ 2 _U_ 1122 _N_ _S_ "U(ASAA)L" {_A_ 2 _U_ 2122 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Double, Int ] 2 { _A_ 2 _U_ 11 _N_ _S_ "U(P)L" {_A_ 2 _U_ 21 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Int, Double ] 2 { _A_ 2 _U_ 11 _N_ _S_ "U(P)L" {_A_ 2 _U_ 21 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
my_fromInt :: Num a => Int -> a
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "U(AAAAAAAASA)L" {_A_ 2 _U_ 11 _N_ _N_ _F_ _IF_ARGS_ 1 2 XC 5 _/\_ u0 -> \ (u1 :: Integer -> u0) (u2 :: Int) -> let {(u4 :: Integer) = case u2 of { _ALG_ I# (u3 :: Int#) -> _#_ int2Integer# [] [u3]; _NO_DEFLT_ }} in _APP_  u1 [ u4 ] _N_} _F_ _IF_ARGS_ 1 2 CC 6 _/\_ u0 -> \ (u1 :: {{Num u0}}) (u2 :: Int) -> let {(u4 :: Integer) = case u2 of { _ALG_ I# (u3 :: Int#) -> _#_ int2Integer# [] [u3]; _NO_DEFLT_ }} in case u1 of { _ALG_ _TUP_10 (u5 :: {{Eq u0}}) (u6 :: {{Text u0}}) (u7 :: u0 -> u0 -> u0) (u8 :: u0 -> u0 -> u0) (u9 :: u0 -> u0 -> u0) (ua :: u0 -> u0) (ub :: u0 -> u0) (uc :: u0 -> u0) (ud :: Integer -> u0) (ue :: Int -> u0) -> _APP_  ud [ u4 ]; _NO_DEFLT_ } _SPECIALISE_ [ Double ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Float ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
paperX :: Int
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 2 _!_ I# [] [280#] _N_ #-}
paperY :: Int
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 2 _!_ I# [] [190#] _N_ #-}
placePEs :: ([PElement], [PElement]) -> [Char]
	{-# GHC_PRAGMA _A_ 0 _U_ 1 _N_ _N_ _N_ _N_ #-}
plot :: [Point] -> [Char]
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ #-}
plotCurve :: Int -> [Point] -> [Char]
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "U(P)L" {_A_ 2 _U_ 21 _N_ _N_ _N_ _N_} _N_ _N_ #-}
postscript :: [Char] -> [Char]
	{-# GHC_PRAGMA _A_ 0 _U_ 2 _N_ _N_ _N_ _N_ #-}
printFloat :: Float -> [Char]
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ #-}
showActive :: Text b => a -> b -> [Char]
	{-# GHC_PRAGMA _A_ 0 _U_ 222 _N_ _N_ _N_ _SPECIALISE_ [ _N_, Int ] 1 { _A_ 0 _U_ 22 _N_ _N_ _N_ _N_ } #-}
showPE :: PElement -> [Char]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(SL)" {_A_ 2 _U_ 11 _N_ _N_ _N_ _N_} _N_ _N_ #-}
showUsed :: [PElement] -> [PElement] -> [Char]
	{-# GHC_PRAGMA _A_ 0 _U_ 22 _N_ _N_ _N_ _N_ #-}

