{-# GHC_PRAGMA INTERFACE VERSION 5 #-}
interface StdLib where
charToInt :: Char -> Int
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 4 \ (u0 :: Char#) -> case _#_ ord# [] [u0] of { _PRIM_ (u1 :: Int#) -> case _#_ minusInt# [] [u1, 48#] of { _PRIM_ (u2 :: Int#) -> _!_ I# [] [u2] } } _N_} _F_ _IF_ARGS_ 0 1 C 5 \ (u0 :: Char) -> case u0 of { _ALG_ C# (u1 :: Char#) -> case _#_ ord# [] [u1] of { _PRIM_ (u2 :: Int#) -> case _#_ minusInt# [] [u2, 48#] of { _PRIM_ (u3 :: Int#) -> _!_ I# [] [u3] } }; _NO_DEFLT_ } _N_ #-}
collect :: Ord a => (b -> a) -> [a] -> [b] -> [b]
	{-# GHC_PRAGMA _A_ 1 _U_ 2222 _N_ _N_ _N_ _N_ #-}
fstcons :: a -> ([a], b) -> ([a], b)
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LU(LL)" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
group :: Ord a => a -> [a] -> ([a], [a])
	{-# GHC_PRAGMA _A_ 1 _U_ 122 _N_ _N_ _N_ _N_ #-}
insert :: Ord a => a -> [a] -> [a]
	{-# GHC_PRAGMA _A_ 1 _U_ 122 _N_ _N_ _N_ _N_ #-}
lines' :: [Char] -> [[Char]]
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _S_ "S" _N_ _N_ #-}
map2 :: (a -> b -> c) -> [a] -> [b] -> [c]
	{-# GHC_PRAGMA _A_ 3 _U_ 211 _N_ _S_ "LSL" _N_ _N_ #-}
mapcat :: (a -> [b]) -> [a] -> [b]
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ #-}
pair :: a -> b -> (a, b)
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 2 2 XX 3 _/\_ u0 u1 -> \ (u2 :: u0) (u3 :: u1) -> _!_ _TUP_2 [u0, u1] [u2, u3] _N_ #-}
remove :: Eq a => a -> [a] -> [a]
	{-# GHC_PRAGMA _A_ 1 _U_ 121 _N_ _N_ _N_ _N_ #-}
replace :: Eq a => a -> [a] -> [a]
	{-# GHC_PRAGMA _A_ 1 _U_ 121 _N_ _N_ _N_ _N_ #-}
sndcons :: b -> (a, [b]) -> (a, [b])
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LU(LL)" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
sort :: Ord a => [a] -> [a]
	{-# GHC_PRAGMA _A_ 1 _U_ 11 _N_ _N_ _N_ _N_ #-}
span' :: (a -> Bool) -> [a] -> ([a], [a])
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _S_ "LS" _N_ _N_ #-}
strToInt :: [Char] -> Int
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _S_ "S" _N_ _N_ #-}

