{-# GHC_PRAGMA INTERFACE VERSION 5 #-}
interface Parse where
class Parse a where
	parseFile :: [Char] -> [a]
	 {-# GHC_PRAGMA {-meth-} _A_ 1 _U_ 12 _N_ _S_ "U(SAAAA)" {_A_ 1 _U_ 12 _N_ _N_ _F_ _IF_ARGS_ 1 1 X 1 _/\_ u0 -> \ (u1 :: [Char] -> [u0]) -> u1 _N_} _F_ _IF_ARGS_ 1 1 C 2 _/\_ u0 -> \ (u1 :: ([Char] -> [u0], [Char] -> u0, [Char] -> (u0, [Char]), [Char] -> (u0, [Char]), u0 -> Bool)) -> case u1 of { _ALG_ _TUP_5 (u2 :: [Char] -> [u0]) (u3 :: [Char] -> u0) (u4 :: [Char] -> (u0, [Char])) (u5 :: [Char] -> (u0, [Char])) (u6 :: u0 -> Bool) -> u2; _NO_DEFLT_ } _N_
		{-defm-} _A_ 2 _U_ 22 _N_ _S_ "LS" _N_ _N_ #-}
	parseLine :: [Char] -> a
	 {-# GHC_PRAGMA {-meth-} _A_ 1 _U_ 12 _N_ _S_ "U(ASAAA)" {_A_ 1 _U_ 12 _N_ _N_ _F_ _IF_ARGS_ 1 1 X 1 _/\_ u0 -> \ (u1 :: [Char] -> u0) -> u1 _N_} _F_ _IF_ARGS_ 1 1 C 2 _/\_ u0 -> \ (u1 :: ([Char] -> [u0], [Char] -> u0, [Char] -> (u0, [Char]), [Char] -> (u0, [Char]), u0 -> Bool)) -> case u1 of { _ALG_ _TUP_5 (u2 :: [Char] -> [u0]) (u3 :: [Char] -> u0) (u4 :: [Char] -> (u0, [Char])) (u5 :: [Char] -> (u0, [Char])) (u6 :: u0 -> Bool) -> u3; _NO_DEFLT_ } _N_
		{-defm-} _A_ 2 _U_ 12 _N_ _S_ "U(AASAA)L" {_A_ 2 _U_ 12 _N_ _N_ _F_ _IF_ARGS_ 1 2 XX 4 _/\_ u0 -> \ (u1 :: [Char] -> (u0, [Char])) (u2 :: [Char]) -> case _APP_  u1 [ u2 ] of { _ALG_ _TUP_2 (u3 :: u0) (u4 :: [Char]) -> u3; _NO_DEFLT_ } _N_} _F_ _IF_ARGS_ 1 2 CX 5 _/\_ u0 -> \ (u1 :: {{Parse u0}}) (u2 :: [Char]) -> case case u1 of { _ALG_ _TUP_5 (u3 :: [Char] -> [u0]) (u4 :: [Char] -> u0) (u5 :: [Char] -> (u0, [Char])) (u6 :: [Char] -> (u0, [Char])) (u7 :: u0 -> Bool) -> _APP_  u5 [ u2 ]; _NO_DEFLT_ } of { _ALG_ _TUP_2 (u8 :: u0) (u9 :: [Char]) -> u8; _NO_DEFLT_ } _N_ #-}
	parse :: [Char] -> (a, [Char])
	 {-# GHC_PRAGMA {-meth-} _A_ 1 _U_ 12 _N_ _S_ "U(AASAA)" {_A_ 1 _U_ 12 _N_ _N_ _F_ _IF_ARGS_ 1 1 X 1 _/\_ u0 -> \ (u1 :: [Char] -> (u0, [Char])) -> u1 _N_} _F_ _IF_ARGS_ 1 1 C 2 _/\_ u0 -> \ (u1 :: ([Char] -> [u0], [Char] -> u0, [Char] -> (u0, [Char]), [Char] -> (u0, [Char]), u0 -> Bool)) -> case u1 of { _ALG_ _TUP_5 (u2 :: [Char] -> [u0]) (u3 :: [Char] -> u0) (u4 :: [Char] -> (u0, [Char])) (u5 :: [Char] -> (u0, [Char])) (u6 :: u0 -> Bool) -> u4; _NO_DEFLT_ } _N_
		{-defm-} _A_ 2 _U_ 11 _N_ _S_ "U(AAASA)L" {_A_ 2 _U_ 11 _N_ _N_ _N_ _N_} _N_ _N_ #-}
	parseType :: [Char] -> (a, [Char])
	 {-# GHC_PRAGMA {-meth-} _A_ 1 _U_ 12 _N_ _S_ "U(AAASA)" {_A_ 1 _U_ 12 _N_ _N_ _F_ _IF_ARGS_ 1 1 X 1 _/\_ u0 -> \ (u1 :: [Char] -> (u0, [Char])) -> u1 _N_} _F_ _IF_ARGS_ 1 1 C 2 _/\_ u0 -> \ (u1 :: ([Char] -> [u0], [Char] -> u0, [Char] -> (u0, [Char]), [Char] -> (u0, [Char]), u0 -> Bool)) -> case u1 of { _ALG_ _TUP_5 (u2 :: [Char] -> [u0]) (u3 :: [Char] -> u0) (u4 :: [Char] -> (u0, [Char])) (u5 :: [Char] -> (u0, [Char])) (u6 :: u0 -> Bool) -> u5; _NO_DEFLT_ } _N_
		{-defm-} _A_ 2 _U_ 02 _N_ _S_ _!_ _F_ _IF_ARGS_ 1 2 XX 3 _/\_ u0 -> \ (u1 :: {{Parse u0}}) (u2 :: [Char]) -> _APP_  _TYAPP_  patError# { ([Char] -> (u0, [Char])) } [ _NOREP_S_ "%DParse.Parse.parseType\"", u2 ] _N_ #-}
	forced :: a -> Bool
	 {-# GHC_PRAGMA {-meth-} _A_ 1 _U_ 12 _N_ _S_ "U(AAAAS)" {_A_ 1 _U_ 12 _N_ _N_ _F_ _IF_ARGS_ 1 1 X 1 _/\_ u0 -> \ (u1 :: u0 -> Bool) -> u1 _N_} _F_ _IF_ARGS_ 1 1 C 2 _/\_ u0 -> \ (u1 :: ([Char] -> [u0], [Char] -> u0, [Char] -> (u0, [Char]), [Char] -> (u0, [Char]), u0 -> Bool)) -> case u1 of { _ALG_ _TUP_5 (u2 :: [Char] -> [u0]) (u3 :: [Char] -> u0) (u4 :: [Char] -> (u0, [Char])) (u5 :: [Char] -> (u0, [Char])) (u6 :: u0 -> Bool) -> u6; _NO_DEFLT_ } _N_
		{-defm-} _A_ 2 _U_ 00 _N_ _S_ "AA" {_A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 1 0 X 1 _/\_ u0 -> _!_ True [] [] _N_} _F_ _IF_ARGS_ 1 2 XX 1 _/\_ u0 -> \ (u1 :: {{Parse u0}}) (u2 :: u0) -> _!_ True [] [] _N_ #-}
seperatedBy :: Char -> [Char] -> [[Char]]
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _S_ "LS" _N_ _N_ #-}
whiteSpace :: [Char] -> [Char]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: [Char]) -> _APP_  _TYAPP_  _ORIG_ PreludeList dropWhile { Char } [ _ORIG_ Prelude isSpace, u0 ] _N_ #-}
instance Parse Char
	{-# GHC_PRAGMA _M_ Parse {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 6 _!_ _TUP_5 [([Char] -> [Char]), ([Char] -> Char), ([Char] -> (Char, [Char])), ([Char] -> (Char, [Char])), (Char -> Bool)] [_CONSTM_ Parse parseFile (Char), _CONSTM_ Parse parseLine (Char), _CONSTM_ Parse parse (Char), _CONSTM_ Parse parseType (Char), _CONSTM_ Parse forced (Char)] _N_
	 parseFile = _A_ 1 _U_ 2 _N_ _N_ _N_ _N_,
	 parseLine = _A_ 1 _U_ 1 _N_ _N_ _N_ _N_,
	 parse = _A_ 1 _U_ 1 _N_ _N_ _N_ _N_,
	 parseType = _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_,
	 forced = _A_ 1 _U_ 0 _N_ _S_ "A" {_A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _!_ True [] [] _N_} _F_ _IF_ARGS_ 0 1 X 1 \ (u0 :: Char) -> _!_ True [] [] _N_ #-}
instance Parse Int
	{-# GHC_PRAGMA _M_ Parse {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 6 _!_ _TUP_5 [([Char] -> [Int]), ([Char] -> Int), ([Char] -> (Int, [Char])), ([Char] -> (Int, [Char])), (Int -> Bool)] [_CONSTM_ Parse parseFile (Int), _CONSTM_ Parse parseLine (Int), _CONSTM_ Parse parse (Int), _CONSTM_ Parse parseType (Int), _CONSTM_ Parse forced (Int)] _N_
	 parseFile = _A_ 1 _U_ 2 _N_ _N_ _N_ _N_,
	 parseLine = _A_ 1 _U_ 1 _N_ _N_ _N_ _N_,
	 parse = _A_ 1 _U_ 1 _N_ _N_ _N_ _N_,
	 parseType = _A_ 1 _U_ 2 _N_ _S_ "S" _N_ _N_,
	 forced = _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ #-}
instance Parse a => Parse [a]
	{-# GHC_PRAGMA _M_ Parse {-dfun-} _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ #-}

