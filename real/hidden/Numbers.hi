{-# GHC_PRAGMA INTERFACE VERSION 5 #-}
interface Numbers where
data Number 	{-# GHC_PRAGMA Tolerant Float #-}
instance Eq Number
	{-# GHC_PRAGMA _M_ Numbers {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Number -> Number -> Bool), (Number -> Number -> Bool)] [_CONSTM_ Eq (==) (Number), _CONSTM_ Eq (/=) (Number)] _N_
	 (==) = _A_ 2 _U_ 11 _N_ _S_ "U(U(P))U(U(P))" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 5 \ (u0 :: Float#) (u1 :: Float#) -> case _#_ minusFloat# [] [u0, u1] of { _PRIM_ (u2 :: Float#) -> case _APP_  _WRKR_ _CONSTM_ Num abs (Float) [ u2 ] of { _ALG_ F# (u3 :: Float#) -> _#_ ltFloat# [] [u3, 1.0000000000000000e-4#]; _NO_DEFLT_ } } _N_} _F_ _ALWAYS_ \ (u0 :: Number) (u1 :: Number) -> case u0 of { _ALG_ _ORIG_ Numbers Tolerant (u2 :: Float) -> case u2 of { _ALG_ F# (u3 :: Float#) -> case u1 of { _ALG_ _ORIG_ Numbers Tolerant (u4 :: Float) -> case u4 of { _ALG_ F# (u5 :: Float#) -> case _#_ minusFloat# [] [u3, u5] of { _PRIM_ (u6 :: Float#) -> case _APP_  _WRKR_ _CONSTM_ Num abs (Float) [ u6 ] of { _ALG_ F# (u7 :: Float#) -> _#_ ltFloat# [] [u7, 1.0000000000000000e-4#]; _NO_DEFLT_ } }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_,
	 (/=) = _A_ 2 _U_ 11 _N_ _S_ "U(U(P))U(U(P))" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 5 \ (u0 :: Float#) (u1 :: Float#) -> case _#_ minusFloat# [] [u0, u1] of { _PRIM_ (u2 :: Float#) -> case _APP_  _WRKR_ _CONSTM_ Num abs (Float) [ u2 ] of { _ALG_ F# (u3 :: Float#) -> _#_ gtFloat# [] [u3, 1.0000000000000000e-4#]; _NO_DEFLT_ } } _N_} _F_ _ALWAYS_ \ (u0 :: Number) (u1 :: Number) -> case u0 of { _ALG_ _ORIG_ Numbers Tolerant (u2 :: Float) -> case u2 of { _ALG_ F# (u3 :: Float#) -> case u1 of { _ALG_ _ORIG_ Numbers Tolerant (u4 :: Float) -> case u4 of { _ALG_ F# (u5 :: Float#) -> case _#_ minusFloat# [] [u3, u5] of { _PRIM_ (u6 :: Float#) -> case _APP_  _WRKR_ _CONSTM_ Num abs (Float) [ u6 ] of { _ALG_ F# (u7 :: Float#) -> _#_ gtFloat# [] [u7, 1.0000000000000000e-4#]; _NO_DEFLT_ } }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ #-}
instance Floating Number
	{-# GHC_PRAGMA _M_ Numbers {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 20 _!_ _TUP_19 [{{Fractional Number}}, Number, (Number -> Number), (Number -> Number), (Number -> Number), (Number -> Number -> Number), (Number -> Number -> Number), (Number -> Number), (Number -> Number), (Number -> Number), (Number -> Number), (Number -> Number), (Number -> Number), (Number -> Number), (Number -> Number), (Number -> Number), (Number -> Number), (Number -> Number), (Number -> Number)] [_DFUN_ Fractional (Number), _CONSTM_ Floating pi (Number), _CONSTM_ Floating exp (Number), _CONSTM_ Floating log (Number), _CONSTM_ Floating sqrt (Number), _CONSTM_ Floating (**) (Number), _CONSTM_ Floating logBase (Number), _CONSTM_ Floating sin (Number), _CONSTM_ Floating cos (Number), _CONSTM_ Floating tan (Number), _CONSTM_ Floating asin (Number), _CONSTM_ Floating acos (Number), _CONSTM_ Floating atan (Number), _CONSTM_ Floating sinh (Number), _CONSTM_ Floating cosh (Number), _CONSTM_ Floating tanh (Number), _CONSTM_ Floating asinh (Number), _CONSTM_ Floating acosh (Number), _CONSTM_ Floating atanh (Number)] _N_
	 pi = _A_ 0 _N_ _N_ _S_ _!_ _F_ _IF_ARGS_ 0 0 X 2 _APP_  _TYAPP_  patError# { Number } [ _NOREP_S_ "%DPreludeCore.Floating.pi\"" ] _N_,
	 exp = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Number) -> _APP_  _TYAPP_  patError# { (Number -> Number) } [ _NOREP_S_ "%DPreludeCore.Floating.exp\"", u0 ] _N_,
	 log = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Number) -> _APP_  _TYAPP_  patError# { (Number -> Number) } [ _NOREP_S_ "%DPreludeCore.Floating.log\"", u0 ] _N_,
	 sqrt = _A_ 1 _U_ 1 _N_ _S_ "U(L)" {_A_ 1 _U_ 1 _N_ _N_ _N_ _N_} _N_ _N_,
	 (**) = _A_ 2 _U_ 22 _N_ _N_ _N_ _N_,
	 logBase = _A_ 2 _U_ 22 _N_ _N_ _N_ _N_,
	 sin = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Number) -> _APP_  _TYAPP_  patError# { (Number -> Number) } [ _NOREP_S_ "%DPreludeCore.Floating.sin\"", u0 ] _N_,
	 cos = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Number) -> _APP_  _TYAPP_  patError# { (Number -> Number) } [ _NOREP_S_ "%DPreludeCore.Floating.cos\"", u0 ] _N_,
	 tan = _A_ 1 _U_ 2 _N_ _N_ _N_ _N_,
	 asin = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Number) -> _APP_  _TYAPP_  patError# { (Number -> Number) } [ _NOREP_S_ "%DPreludeCore.Floating.asin\"", u0 ] _N_,
	 acos = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Number) -> _APP_  _TYAPP_  patError# { (Number -> Number) } [ _NOREP_S_ "%DPreludeCore.Floating.acos\"", u0 ] _N_,
	 atan = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Number) -> _APP_  _TYAPP_  patError# { (Number -> Number) } [ _NOREP_S_ "%DPreludeCore.Floating.atan\"", u0 ] _N_,
	 sinh = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Number) -> _APP_  _TYAPP_  patError# { (Number -> Number) } [ _NOREP_S_ "%DPreludeCore.Floating.sinh\"", u0 ] _N_,
	 cosh = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Number) -> _APP_  _TYAPP_  patError# { (Number -> Number) } [ _NOREP_S_ "%DPreludeCore.Floating.cosh\"", u0 ] _N_,
	 tanh = _A_ 1 _U_ 2 _N_ _N_ _N_ _N_,
	 asinh = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Number) -> _APP_  _TYAPP_  patError# { (Number -> Number) } [ _NOREP_S_ "%DPreludeCore.Floating.asinh\"", u0 ] _N_,
	 acosh = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Number) -> _APP_  _TYAPP_  patError# { (Number -> Number) } [ _NOREP_S_ "%DPreludeCore.Floating.acosh\"", u0 ] _N_,
	 atanh = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Number) -> _APP_  _TYAPP_  patError# { (Number -> Number) } [ _NOREP_S_ "%DPreludeCore.Floating.atanh\"", u0 ] _N_ #-}
instance Fractional Number
	{-# GHC_PRAGMA _M_ Numbers {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 5 _!_ _TUP_4 [{{Num Number}}, (Number -> Number -> Number), (Number -> Number), (Ratio Integer -> Number)] [_DFUN_ Num (Number), _CONSTM_ Fractional (/) (Number), _CONSTM_ Fractional recip (Number), _CONSTM_ Fractional fromRational (Number)] _N_
	 (/) = _A_ 2 _U_ 11 _N_ _S_ "U(L)U(L)" {_A_ 2 _U_ 11 _N_ _N_ _N_ _N_} _N_ _N_,
	 recip = _A_ 0 _U_ 2 _N_ _N_ _N_ _N_,
	 fromRational = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Ratio Integer) -> _APP_  _TYAPP_  patError# { (Ratio Integer -> Number) } [ _NOREP_S_ "%DPreludeCore.Fractional.fromRational\"", u0 ] _N_ #-}
instance Num Number
	{-# GHC_PRAGMA _M_ Numbers {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 11 _!_ _TUP_10 [{{Eq Number}}, {{Text Number}}, (Number -> Number -> Number), (Number -> Number -> Number), (Number -> Number -> Number), (Number -> Number), (Number -> Number), (Number -> Number), (Integer -> Number), (Int -> Number)] [_DFUN_ Eq (Number), _DFUN_ Text (Number), _CONSTM_ Num (+) (Number), _CONSTM_ Num (-) (Number), _CONSTM_ Num (*) (Number), _CONSTM_ Num negate (Number), _CONSTM_ Num abs (Number), _CONSTM_ Num signum (Number), _CONSTM_ Num fromInteger (Number), _CONSTM_ Num fromInt (Number)] _N_
	 (+) = _A_ 2 _U_ 11 _N_ _S_ "U(L)U(L)" {_A_ 2 _U_ 11 _N_ _N_ _N_ _N_} _N_ _N_,
	 (-) = _A_ 2 _U_ 11 _N_ _S_ "U(L)U(L)" {_A_ 2 _U_ 11 _N_ _N_ _N_ _N_} _N_ _N_,
	 (*) = _A_ 2 _U_ 11 _N_ _S_ "U(L)U(L)" {_A_ 2 _U_ 11 _N_ _N_ _N_ _N_} _N_ _N_,
	 negate = _A_ 1 _U_ 1 _N_ _S_ "U(L)" {_A_ 1 _U_ 1 _N_ _N_ _N_ _N_} _N_ _N_,
	 abs = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Number) -> _APP_  _TYAPP_  patError# { (Number -> Number) } [ _NOREP_S_ "%DPreludeCore.Num.abs\"", u0 ] _N_,
	 signum = _A_ 1 _U_ 2 _N_ _S_ _!_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Number) -> _APP_  _TYAPP_  patError# { (Number -> Number) } [ _NOREP_S_ "%DPreludeCore.Num.signum\"", u0 ] _N_,
	 fromInteger = _A_ 1 _U_ 1 _N_ _N_ _N_ _N_,
	 fromInt = _A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 0 1 C 5 \ (u0 :: Int) -> let {(u2 :: Integer) = case u0 of { _ALG_ I# (u1 :: Int#) -> _#_ int2Integer# [] [u1]; _NO_DEFLT_ }} in _APP_  _CONSTM_ Num fromInteger (Number) [ u2 ] _N_ #-}
instance Ord Number
	{-# GHC_PRAGMA _M_ Numbers {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 9 _!_ _TUP_8 [{{Eq Number}}, (Number -> Number -> Bool), (Number -> Number -> Bool), (Number -> Number -> Bool), (Number -> Number -> Bool), (Number -> Number -> Number), (Number -> Number -> Number), (Number -> Number -> _CMP_TAG)] [_DFUN_ Eq (Number), _CONSTM_ Ord (<) (Number), _CONSTM_ Ord (<=) (Number), _CONSTM_ Ord (>=) (Number), _CONSTM_ Ord (>) (Number), _CONSTM_ Ord max (Number), _CONSTM_ Ord min (Number), _CONSTM_ Ord _tagCmp (Number)] _N_
	 (<) = _A_ 2 _U_ 11 _N_ _S_ "U(U(P))U(U(P))" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 2 \ (u0 :: Float#) (u1 :: Float#) -> case _#_ minusFloat# [] [u1, 1.0000000000000000e-4#] of { _PRIM_ (u2 :: Float#) -> _#_ ltFloat# [] [u0, u2] } _N_} _F_ _IF_ARGS_ 0 2 CC 6 \ (u0 :: Number) (u1 :: Number) -> case u0 of { _ALG_ _ORIG_ Numbers Tolerant (u2 :: Float) -> case u1 of { _ALG_ _ORIG_ Numbers Tolerant (u3 :: Float) -> case u2 of { _ALG_ F# (u4 :: Float#) -> case u3 of { _ALG_ F# (u5 :: Float#) -> case _#_ minusFloat# [] [u5, 1.0000000000000000e-4#] of { _PRIM_ (u6 :: Float#) -> _#_ ltFloat# [] [u4, u6] }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_,
	 (<=) = _A_ 2 _U_ 11 _N_ _S_ "U(U(P))U(U(P))" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 2 \ (u0 :: Float#) (u1 :: Float#) -> case _#_ minusFloat# [] [u0, 1.0000000000000000e-4#] of { _PRIM_ (u2 :: Float#) -> _#_ ltFloat# [] [u2, u1] } _N_} _F_ _IF_ARGS_ 0 2 CC 6 \ (u0 :: Number) (u1 :: Number) -> case u0 of { _ALG_ _ORIG_ Numbers Tolerant (u2 :: Float) -> case u1 of { _ALG_ _ORIG_ Numbers Tolerant (u3 :: Float) -> case u2 of { _ALG_ F# (u4 :: Float#) -> case _#_ minusFloat# [] [u4, 1.0000000000000000e-4#] of { _PRIM_ (u5 :: Float#) -> case u3 of { _ALG_ F# (u6 :: Float#) -> _#_ ltFloat# [] [u5, u6]; _NO_DEFLT_ } }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_,
	 (>=) = _A_ 2 _U_ 11 _N_ _S_ "U(U(P))U(U(P))" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 2 \ (u0 :: Float#) (u1 :: Float#) -> case _#_ minusFloat# [] [u1, 1.0000000000000000e-4#] of { _PRIM_ (u2 :: Float#) -> _#_ ltFloat# [] [u2, u0] } _N_} _F_ _IF_ARGS_ 0 2 XX 3 \ (u0 :: Number) (u1 :: Number) -> _APP_  _CONSTM_ Ord (<=) (Number) [ u1, u0 ] _N_,
	 (>) = _A_ 2 _U_ 11 _N_ _S_ "U(U(P))U(U(P))" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 2 \ (u0 :: Float#) (u1 :: Float#) -> case _#_ minusFloat# [] [u0, 1.0000000000000000e-4#] of { _PRIM_ (u2 :: Float#) -> _#_ ltFloat# [] [u1, u2] } _N_} _F_ _IF_ARGS_ 0 2 XX 3 \ (u0 :: Number) (u1 :: Number) -> _APP_  _CONSTM_ Ord (<) (Number) [ u1, u0 ] _N_,
	 max = _A_ 2 _U_ 22 _N_ _N_ _N_ _N_,
	 min = _A_ 2 _U_ 22 _N_ _N_ _N_ _N_,
	 _tagCmp = _A_ 2 _U_ 22 _N_ _N_ _N_ _N_ #-}
instance Text Number
	{-# GHC_PRAGMA _M_ Numbers {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 5 _!_ _TUP_4 [(Int -> [Char] -> [(Number, [Char])]), (Int -> Number -> [Char] -> [Char]), ([Char] -> [([Number], [Char])]), ([Number] -> [Char] -> [Char])] [_CONSTM_ Text readsPrec (Number), _CONSTM_ Text showsPrec (Number), _CONSTM_ Text readList (Number), _CONSTM_ Text showList (Number)] _N_
	 readsPrec = _A_ 2 _U_ 02 _N_ _S_ "AL" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_,
	 showsPrec = _A_ 2 _U_ 212 _N_ _S_ "LU(L)" {_A_ 1 _U_ 222 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _CONSTM_ Text showsPrec (Float) _N_} _F_ _IF_ARGS_ 0 2 XC 4 \ (u0 :: Int) (u1 :: Number) -> case u1 of { _ALG_ _ORIG_ Numbers Tolerant (u2 :: Float) -> _APP_  _CONSTM_ Text showsPrec (Float) [ u0, u2 ]; _NO_DEFLT_ } _N_,
	 readList = _A_ 0 _U_ 2 _N_ _N_ _N_ _N_,
	 showList = _A_ 0 _U_ 12 _N_ _N_ _N_ _N_ #-}

