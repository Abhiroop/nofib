{-# GHC_PRAGMA INTERFACE VERSION 5 #-}
interface Vectors where
import Numbers(Number)
data Vector 	{-# GHC_PRAGMA Vec [Number] #-}
inpr :: Vector -> Vector -> Number
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "U(S)U(L)" {_A_ 2 _U_ 11 _N_ _N_ _N_ _N_} _N_ _N_ #-}
len :: Vector -> Number
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(S)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ #-}
mulv :: Number -> Vector -> Vector
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LU(L)" {_A_ 2 _U_ 21 _N_ _N_ _N_ _N_} _N_ _N_ #-}
norm :: Vector -> Vector
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(L)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ #-}
vec :: [Number] -> Vector
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 2 \ (u0 :: [Number]) -> _!_ _ORIG_ Vectors Vec [] [u0] _N_ #-}
x :: Vector -> Number
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(S)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ #-}
y :: Vector -> Number
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(S)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ #-}
z :: Vector -> Number
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(S)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ #-}
instance Eq Vector
	{-# GHC_PRAGMA _M_ Vectors {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Vector -> Vector -> Bool), (Vector -> Vector -> Bool)] [_CONSTM_ Eq (==) (Vector), _CONSTM_ Eq (/=) (Vector)] _N_
	 (==) = _A_ 2 _U_ 11 _N_ _S_ "U(L)U(L)" {_A_ 0 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_,
	 (/=) = _A_ 2 _U_ 11 _N_ _S_ "U(L)U(L)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
instance Num Vector
	{-# GHC_PRAGMA _M_ Vectors {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 11 _!_ _TUP_10 [{{Eq Vector}}, {{Text Vector}}, (Vector -> Vector -> Vector), (Vector -> Vector -> Vector), (Vector -> Vector -> Vector), (Vector -> Vector), (Vector -> Vector), (Vector -> Vector), (Integer -> Vector), (Int -> Vector)] [_DFUN_ Eq (Vector), _DFUN_ Text (Vector), _CONSTM_ Num (+) (Vector), _CONSTM_ Num (-) (Vector), _CONSTM_ Num (*) (Vector), _CONSTM_ Num negate (Vector), _CONSTM_ Num abs (Vector), _ORIG_ Vectors norm, _CONSTM_ Num fromInteger (Vector), _CONSTM_ Num fromInt (Vector)] _N_
	 (+) = _A_ 2 _U_ 11 _N_ _S_ "U(L)U(L)" {_A_ 2 _U_ 11 _N_ _N_ _N_ _N_} _N_ _N_,
	 (-) = _A_ 2 _U_ 11 _N_ _S_ "U(L)U(L)" {_A_ 2 _U_ 11 _N_ _N_ _N_ _N_} _N_ _N_,
	 (*) = _A_ 2 _U_ 22 _N_ _N_ _N_ _N_,
	 negate = _A_ 1 _U_ 1 _N_ _S_ "U(L)" {_A_ 1 _U_ 1 _N_ _N_ _N_ _N_} _N_ _N_,
	 abs = _A_ 1 _U_ 1 _N_ _N_ _N_ _N_,
	 signum = _A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _ORIG_ Vectors norm _N_,
	 fromInteger = _A_ 1 _U_ 1 _N_ _S_ "U(PPP)" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_,
	 fromInt = _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _F_ _IF_ARGS_ 0 1 C 5 \ (u0 :: Int) -> let {(u2 :: Integer) = case u0 of { _ALG_ I# (u1 :: Int#) -> _#_ int2Integer# [] [u1]; _NO_DEFLT_ }} in _APP_  _CONSTM_ Num fromInteger (Vector) [ u2 ] _N_ #-}
instance Text Vector
	{-# GHC_PRAGMA _M_ Vectors {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 5 _!_ _TUP_4 [(Int -> [Char] -> [(Vector, [Char])]), (Int -> Vector -> [Char] -> [Char]), ([Char] -> [([Vector], [Char])]), ([Vector] -> [Char] -> [Char])] [_CONSTM_ Text readsPrec (Vector), _CONSTM_ Text showsPrec (Vector), _CONSTM_ Text readList (Vector), _CONSTM_ Text showList (Vector)] _N_
	 readsPrec = _A_ 1 _U_ 12 _N_ _S_ "U(P)" {_A_ 1 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_,
	 showsPrec = _A_ 2 _U_ 112 _N_ _S_ "LU(L)" {_A_ 2 _U_ 122 _N_ _N_ _N_ _N_} _N_ _N_,
	 readList = _A_ 0 _U_ 2 _N_ _N_ _N_ _N_,
	 showList = _A_ 0 _U_ 12 _N_ _N_ _N_ _N_ #-}

