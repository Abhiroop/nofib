{-# GHC_PRAGMA INTERFACE VERSION 5 #-}
interface Viterbi where
import BalBinSTrees(BalBinSTree(..), bbstBuild, bbstDepth, bbstFlatten, bbstInsert, bbstInsertQuiet, bbstLookUp, bbstMember, bbstShowKeys)
import HmmDensities(GaussianComponent(..), LogDensityTable(..), TiedMixture(..), TmTable(..), eval_log_densities, extern_to_intern, readMixture, readMixtures)
import HmmDigraphs(HmmData(..), HmmNetworkDic(..), HmmState(..), HmmTsA(..), HmmTsL(..), ProbArc(..), ProbDigraphA(..), ProbDigraphL(..), ProbDigraphNode(..), buildHmm, build_hmm_array, convert_to_log_probs, get_log_probs, readHmms)
import MathTypes(Vector(..))
import MaybeStateT(MST(..), bindMST, returnMST, thenMST)
import Native(Bytes(..), Native(..), bytesToLongInt, bytesToShortInt, longIntToBytes, readB, shortIntToBytes, showB)
import Phones(Phone(..), phone_bounds, phone_list)
import PreludeArray(Array, Assoc)
import PreludeStdIO(Maybe)
import Pronunciations(DictionaryEntry(..), Digraph(..), DigraphNode(..), PrnNetwork(..), Word(..), pre_hmm, readDictionary, readsPrnNetwork, showPrnNetwork)
class Native a where
	showBytes :: a -> [Char] -> [Char]
	 {-# GHC_PRAGMA {-meth-} _A_ 1 _U_ 122 _N_ _S_ "S" _F_ _IF_ARGS_ 1 1 C 2 _/\_ u0 -> \ (u1 :: (u0 -> [Char] -> [Char], [Char] -> Maybe (u0, [Char]), [u0] -> [Char] -> [Char], Int -> [Char] -> Maybe ([u0], [Char]))) -> case u1 of { _ALG_ _TUP_4 (u2 :: u0 -> [Char] -> [Char]) (u3 :: [Char] -> Maybe (u0, [Char])) (u4 :: [u0] -> [Char] -> [Char]) (u5 :: Int -> [Char] -> Maybe ([u0], [Char])) -> u2; _NO_DEFLT_ } _N_
		{-defm-} _A_ 3 _U_ 022 _N_ _S_ _!_ _F_ _IF_ARGS_ 1 3 XXX 4 _/\_ u0 -> \ (u1 :: {{Native u0}}) (u2 :: u0) (u3 :: [Char]) -> _APP_  _TYAPP_  patError# { (u0 -> [Char] -> [Char]) } [ _NOREP_S_ "%DNative.Native.showBytes\"", u2, u3 ] _N_ #-}
	readBytes :: [Char] -> Maybe (a, [Char])
	 {-# GHC_PRAGMA {-meth-} _A_ 1 _U_ 12 _N_ _S_ "S" _F_ _IF_ARGS_ 1 1 C 2 _/\_ u0 -> \ (u1 :: (u0 -> [Char] -> [Char], [Char] -> Maybe (u0, [Char]), [u0] -> [Char] -> [Char], Int -> [Char] -> Maybe ([u0], [Char]))) -> case u1 of { _ALG_ _TUP_4 (u2 :: u0 -> [Char] -> [Char]) (u3 :: [Char] -> Maybe (u0, [Char])) (u4 :: [u0] -> [Char] -> [Char]) (u5 :: Int -> [Char] -> Maybe ([u0], [Char])) -> u3; _NO_DEFLT_ } _N_
		{-defm-} _A_ 2 _U_ 02 _N_ _S_ _!_ _F_ _IF_ARGS_ 1 2 XX 3 _/\_ u0 -> \ (u1 :: {{Native u0}}) (u2 :: [Char]) -> _APP_  _TYAPP_  patError# { ([Char] -> Maybe (u0, [Char])) } [ _NOREP_S_ "%DNative.Native.readBytes\"", u2 ] _N_ #-}
	listShowBytes :: [a] -> [Char] -> [Char]
	 {-# GHC_PRAGMA {-meth-} _A_ 1 _U_ 122 _N_ _S_ "S" _F_ _IF_ARGS_ 1 1 C 2 _/\_ u0 -> \ (u1 :: (u0 -> [Char] -> [Char], [Char] -> Maybe (u0, [Char]), [u0] -> [Char] -> [Char], Int -> [Char] -> Maybe ([u0], [Char]))) -> case u1 of { _ALG_ _TUP_4 (u2 :: u0 -> [Char] -> [Char]) (u3 :: [Char] -> Maybe (u0, [Char])) (u4 :: [u0] -> [Char] -> [Char]) (u5 :: Int -> [Char] -> Maybe ([u0], [Char])) -> u4; _NO_DEFLT_ } _N_
		{-defm-} _A_ 3 _U_ 112 _N_ _S_ "LSL" _N_ _N_ #-}
	listReadBytes :: Int -> [Char] -> Maybe ([a], [Char])
	 {-# GHC_PRAGMA {-meth-} _A_ 1 _U_ 122 _N_ _S_ "S" _F_ _IF_ARGS_ 1 1 C 2 _/\_ u0 -> \ (u1 :: (u0 -> [Char] -> [Char], [Char] -> Maybe (u0, [Char]), [u0] -> [Char] -> [Char], Int -> [Char] -> Maybe ([u0], [Char]))) -> case u1 of { _ALG_ _TUP_4 (u2 :: u0 -> [Char] -> [Char]) (u3 :: [Char] -> Maybe (u0, [Char])) (u4 :: [u0] -> [Char] -> [Char]) (u5 :: Int -> [Char] -> Maybe ([u0], [Char])) -> u5; _NO_DEFLT_ } _N_
		{-defm-} _A_ 3 _U_ 112 _N_ _S_ "LSL" _N_ _N_ #-}
data BalBinSTree a b 	{-# GHC_PRAGMA Nil | Node a b (BalBinSTree a b) (BalBinSTree a b) #-}
type GaussianComponent = (Float, [Float], [Float])
type LogDensityTable = Array Phone (Array Int Float)
data TiedMixture   = Gm [(Float, [Float], [Float])] | Tie Phone Int
type TmTable = Array Phone (Array Int TiedMixture)
type HmmData = (Phone, Int)
type HmmNetworkDic = Array Phone (HmmTsL Int)
type HmmState = Int
data HmmTsA a   = HmmTsA [(Int, Float)] [(Int, Float)] (Array Int (a, [(Int, Float)]))
data HmmTsL a   = HmmTsL Int [(Int, Float)] [(Int, Float)] [(a, [(Int, Float)])]
type ProbArc = (Int, Float)
type ProbDigraphA a = Array Int (a, [(Int, Float)])
type ProbDigraphL a = [(a, [(Int, Float)])]
type ProbDigraphNode a = (a, [(Int, Float)])
type Vector = [Float]
type MST a b = a -> Maybe (b, a)
type Bytes = [Char]
data Phone   = AA | AE | AH | AO | AW | AX | AXR | AY | EH | ER | EY | IH | IX | IY | OW | OY | UH | UW | L | EL | R | W | Y | M | N | EN | NG | F | TH | S | SH | HH | V | DH | Z | ZH | CH | JH | P | T | K | B | D | G | DX | SIL
type DictionaryEntry a = ([Char], PrnNetwork a)
type Digraph a = [(a, [Int])]
type DigraphNode a = (a, [Int])
data PrnNetwork a   = PrnN Int [Int] [Int] [(a, [Int])]
type Word = [Char]
align :: HmmTsA (Phone, Int) -> [Array Phone (Array Int Float)] -> (Float, [(Phone, Int)])
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _N_ _N_ _N_ #-}
bbstBuild :: Ord a => [(a, b)] -> BalBinSTree a b
	{-# GHC_PRAGMA _A_ 1 _U_ 21 _N_ _N_ _N_ _N_ #-}
bbstDepth :: BalBinSTree a b -> Int
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
bbstFlatten :: BalBinSTree a b -> [(a, b)]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
bbstInsert :: Ord a => BalBinSTree a b -> (a, b) -> BalBinSTree a b
	{-# GHC_PRAGMA _A_ 3 _U_ 221 _N_ _N_ _N_ _N_ #-}
bbstInsertQuiet :: Ord a => BalBinSTree a b -> (a, b) -> BalBinSTree a b
	{-# GHC_PRAGMA _A_ 3 _U_ 221 _N_ _N_ _N_ _N_ #-}
bbstLookUp :: (Ord a, Text a) => BalBinSTree a b -> a -> b
	{-# GHC_PRAGMA _A_ 2 _U_ 1122 _N_ _S_ "U(LSAALAAA)L" {_A_ 4 _U_ 122112 _N_ _N_ _N_ _N_} _N_ _N_ #-}
bbstMember :: Ord b => BalBinSTree b a -> b -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 212 _N_ _N_ _N_ _N_ #-}
bbstShowKeys :: Text a => Int -> BalBinSTree a b -> [Char]
	{-# GHC_PRAGMA _A_ 1 _U_ 111 _N_ _N_ _N_ _N_ #-}
eval_log_densities :: Array Phone (Array Int TiedMixture) -> [Float] -> Array Phone (Array Int Float)
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _N_ _N_ _N_ #-}
extern_to_intern :: [(Float, [Float], [Float])] -> [(Float, [Float], [Float])]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
readMixture :: [Char] -> Maybe ([(Float, [Float], [Float])], [Char])
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ #-}
readMixtures :: [Char] -> [[(Float, [Float], [Float])]]
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ #-}
buildHmm :: Array Phone (HmmTsL Int) -> PrnNetwork (Phone, Int) -> HmmTsA (Phone, Int)
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LU(LLLL)" {_A_ 5 _U_ 22111 _N_ _N_ _N_ _N_} _N_ _N_ #-}
build_hmm_array :: [Assoc Phone (HmmTsL Int)] -> Array Phone (HmmTsL Int)
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _S_ "S" _N_ _N_ #-}
convert_to_log_probs :: HmmTsL a -> HmmTsL a
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(LLLL)" {_A_ 4 _U_ 2111 _N_ _N_ _N_ _N_} _N_ _N_ #-}
get_log_probs :: Ix a => Array a (HmmTsL b) -> Array a (HmmTsL b)
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _S_ "U(ASLA)L" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
readHmms :: [Char] -> [Assoc Phone (HmmTsL Int)]
	{-# GHC_PRAGMA _A_ 0 _U_ 2 _N_ _N_ _N_ _N_ #-}
bindMST :: (b -> Maybe (a, b)) -> (a -> b -> Maybe (c, b)) -> b -> Maybe (c, b)
	{-# GHC_PRAGMA _A_ 3 _U_ 112 _N_ _S_ "SLL" _N_ _N_ #-}
returnMST :: b -> a -> Maybe (b, a)
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _N_ _N_ _N_ #-}
thenMST :: (b -> Maybe (a, b)) -> (a -> b -> Maybe (c, b)) -> b -> Maybe (c, b)
	{-# GHC_PRAGMA _A_ 3 _U_ 112 _N_ _S_ "SLL" _N_ _N_ #-}
bytesToLongInt :: [Char] -> Maybe (Int, [Char])
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ #-}
bytesToShortInt :: [Char] -> Maybe (Int, [Char])
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ #-}
longIntToBytes :: Int -> [Char] -> [Char]
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _S_ "U(P)L" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
readB :: Native a => [Char] -> a
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _S_ "U(ASAA)L" {_A_ 2 _U_ 12 _N_ _N_ _N_ _N_} _N_ _N_ #-}
shortIntToBytes :: Int -> [Char] -> [Char]
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _S_ "U(P)L" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
showB :: Native a => a -> [Char]
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _S_ "U(SAAA)L" {_A_ 2 _U_ 12 _N_ _N_ _N_ _N_} _F_ _IF_ARGS_ 1 2 CX 6 _/\_ u0 -> \ (u1 :: {{Native u0}}) (u2 :: u0) -> let {(u3 :: [Char]) = _!_ _NIL_ [Char] []} in case u1 of { _ALG_ _TUP_4 (u4 :: u0 -> [Char] -> [Char]) (u5 :: [Char] -> Maybe (u0, [Char])) (u6 :: [u0] -> [Char] -> [Char]) (u7 :: Int -> [Char] -> Maybe ([u0], [Char])) -> _APP_  u4 [ u2, u3 ]; _NO_DEFLT_ } _N_ #-}
phone_bounds :: (Phone, Phone)
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _N_ _N_ _N_ #-}
phone_list :: [Phone]
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 2 _APP_  _CONSTM_ Ix range (Phone) [ _ORIG_ Phones phone_bounds ] _N_ #-}
pre_hmm :: BalBinSTree [Char] (PrnNetwork Phone) -> [Char] -> PrnNetwork (Phone, Int)
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _N_ _N_ _N_ #-}
readDictionary :: [Char] -> [([Char], PrnNetwork Phone)]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
readsPrnNetwork :: Text a => [Char] -> Maybe (PrnNetwork a, [Char])
	{-# GHC_PRAGMA _A_ 0 _U_ 12 _N_ _N_ _N_ _SPECIALISE_ [ Phone ] 1 { _A_ 0 _U_ 2 _N_ _N_ _N_ _N_ } #-}
showPrnNetwork :: Text a => PrnNetwork a -> [Char]
	{-# GHC_PRAGMA _A_ 0 _U_ 11 _N_ _N_ _N_ _N_ #-}
instance Enum Phone
	{-# GHC_PRAGMA _M_ Phones {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 6 _!_ _TUP_5 [{{Ord Phone}}, (Phone -> [Phone]), (Phone -> Phone -> [Phone]), (Phone -> Phone -> [Phone]), (Phone -> Phone -> Phone -> [Phone])] [_DFUN_ Ord (Phone), _CONSTM_ Enum enumFrom (Phone), _CONSTM_ Enum enumFromThen (Phone), _CONSTM_ Enum enumFromTo (Phone), _CONSTM_ Enum enumFromThenTo (Phone)] _N_
	 enumFrom = _A_ 1 _U_ 1 _N_ _S_ "E" _N_ _N_,
	 enumFromThen = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_,
	 enumFromTo = _A_ 2 _U_ 22 _N_ _N_ _N_ _N_,
	 enumFromThenTo = _A_ 3 _U_ 222 _N_ _N_ _N_ _N_ #-}
instance Eq Phone
	{-# GHC_PRAGMA _M_ Phones {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Phone -> Phone -> Bool), (Phone -> Phone -> Bool)] [_CONSTM_ Eq (==) (Phone), _CONSTM_ Eq (/=) (Phone)] _N_
	 (==) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_,
	 (/=) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_ #-}
instance Ix Phone
	{-# GHC_PRAGMA _M_ Phones {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 5 _!_ _TUP_4 [{{Ord Phone}}, ((Phone, Phone) -> [Phone]), ((Phone, Phone) -> Phone -> Int), ((Phone, Phone) -> Phone -> Bool)] [_DFUN_ Ord (Phone), _CONSTM_ Ix range (Phone), _CONSTM_ Ix index (Phone), _CONSTM_ Ix inRange (Phone)] _N_
	 range = _A_ 1 _U_ 1 _N_ _S_ "U(EE)" {_A_ 2 _U_ 11 _N_ _N_ _N_ _N_} _N_ _N_,
	 index = _A_ 2 _U_ 12 _N_ _S_ "U(EE)E" {_A_ 3 _U_ 212 _N_ _N_ _N_ _N_} _N_ _N_,
	 inRange = _A_ 2 _U_ 11 _N_ _S_ "U(EE)E" {_A_ 3 _U_ 111 _N_ _N_ _N_ _N_} _N_ _N_ #-}
instance (Native a, Native b) => Native (a, b)
	{-# GHC_PRAGMA _M_ Native {-dfun-} _A_ 2 _U_ 22 _N_ _N_ _N_ _N_ #-}
instance (Native a, Native b, Native c) => Native (a, b, c)
	{-# GHC_PRAGMA _M_ Native {-dfun-} _A_ 3 _U_ 222 _N_ _N_ _N_ _N_ #-}
instance (Native a, Ix a, Native b) => Native (Array a b)
	{-# GHC_PRAGMA _M_ Native {-dfun-} _A_ 3 _U_ 222 _N_ _N_ _N_ _N_ #-}
instance Native Bool
	{-# GHC_PRAGMA _M_ Native {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 5 _!_ _TUP_4 [(Bool -> [Char] -> [Char]), ([Char] -> Maybe (Bool, [Char])), ([Bool] -> [Char] -> [Char]), (Int -> [Char] -> Maybe ([Bool], [Char]))] [_CONSTM_ Native showBytes (Bool), _CONSTM_ Native readBytes (Bool), _CONSTM_ Native listShowBytes (Bool), _CONSTM_ Native listReadBytes (Bool)] _N_
	 showBytes = _A_ 2 _U_ 12 _N_ _S_ "EL" _N_ _N_,
	 readBytes = _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_,
	 listShowBytes = _A_ 2 _U_ 12 _N_ _N_ _N_ _N_,
	 listReadBytes = _A_ 2 _U_ 12 _N_ _N_ _N_ _N_ #-}
instance Native Char
	{-# GHC_PRAGMA _M_ Native {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 5 _!_ _TUP_4 [(Char -> [Char] -> [Char]), ([Char] -> Maybe (Char, [Char])), ([Char] -> [Char] -> [Char]), (Int -> [Char] -> Maybe ([Char], [Char]))] [_CONSTM_ Native showBytes (Char), _CONSTM_ Native readBytes (Char), _CONSTM_ Native listShowBytes (Char), _CONSTM_ Native listReadBytes (Char)] _N_
	 showBytes = _A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 3 \ (u0 :: Char) (u1 :: [Char]) -> _!_ (:) [Char] [u0, u1] _N_,
	 readBytes = _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_,
	 listShowBytes = _A_ 2 _U_ 12 _N_ _N_ _N_ _N_,
	 listReadBytes = _A_ 2 _U_ 12 _N_ _S_ "U(P)L" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
instance Native Double
	{-# GHC_PRAGMA _M_ Native {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 5 _!_ _TUP_4 [(Double -> [Char] -> [Char]), ([Char] -> Maybe (Double, [Char])), ([Double] -> [Char] -> [Char]), (Int -> [Char] -> Maybe ([Double], [Char]))] [_CONSTM_ Native showBytes (Double), _CONSTM_ Native readBytes (Double), _CONSTM_ Native listShowBytes (Double), _CONSTM_ Native listReadBytes (Double)] _N_
	 showBytes = _A_ 2 _U_ 12 _N_ _S_ "U(P)L" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_,
	 readBytes = _A_ 1 _U_ 2 _N_ _N_ _N_ _N_,
	 listShowBytes = _A_ 2 _U_ 12 _N_ _N_ _N_ _N_,
	 listReadBytes = _A_ 2 _U_ 12 _N_ _N_ _N_ _N_ #-}
instance Native Float
	{-# GHC_PRAGMA _M_ Native {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 5 _!_ _TUP_4 [(Float -> [Char] -> [Char]), ([Char] -> Maybe (Float, [Char])), ([Float] -> [Char] -> [Char]), (Int -> [Char] -> Maybe ([Float], [Char]))] [_CONSTM_ Native showBytes (Float), _CONSTM_ Native readBytes (Float), _CONSTM_ Native listShowBytes (Float), _CONSTM_ Native listReadBytes (Float)] _N_
	 showBytes = _A_ 2 _U_ 12 _N_ _S_ "U(P)L" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_,
	 readBytes = _A_ 1 _U_ 2 _N_ _N_ _N_ _N_,
	 listShowBytes = _A_ 2 _U_ 12 _N_ _N_ _N_ _N_,
	 listReadBytes = _A_ 2 _U_ 12 _N_ _N_ _N_ _N_ #-}
instance Native Int
	{-# GHC_PRAGMA _M_ Native {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 5 _!_ _TUP_4 [(Int -> [Char] -> [Char]), ([Char] -> Maybe (Int, [Char])), ([Int] -> [Char] -> [Char]), (Int -> [Char] -> Maybe ([Int], [Char]))] [_CONSTM_ Native showBytes (Int), _CONSTM_ Native readBytes (Int), _CONSTM_ Native listShowBytes (Int), _CONSTM_ Native listReadBytes (Int)] _N_
	 showBytes = _A_ 2 _U_ 12 _N_ _S_ "U(P)L" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_,
	 readBytes = _A_ 1 _U_ 2 _N_ _N_ _N_ _N_,
	 listShowBytes = _A_ 2 _U_ 12 _N_ _N_ _N_ _N_,
	 listReadBytes = _A_ 2 _U_ 12 _N_ _N_ _N_ _N_ #-}
instance Native a => Native (Maybe a)
	{-# GHC_PRAGMA _M_ Native {-dfun-} _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ #-}
instance Native a => Native [a]
	{-# GHC_PRAGMA _M_ Native {-dfun-} _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ #-}
instance Ord Phone
	{-# GHC_PRAGMA _M_ Phones {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 9 _!_ _TUP_8 [{{Eq Phone}}, (Phone -> Phone -> Bool), (Phone -> Phone -> Bool), (Phone -> Phone -> Bool), (Phone -> Phone -> Bool), (Phone -> Phone -> Phone), (Phone -> Phone -> Phone), (Phone -> Phone -> _CMP_TAG)] [_DFUN_ Eq (Phone), _CONSTM_ Ord (<) (Phone), _CONSTM_ Ord (<=) (Phone), _CONSTM_ Ord (>=) (Phone), _CONSTM_ Ord (>) (Phone), _CONSTM_ Ord max (Phone), _CONSTM_ Ord min (Phone), _CONSTM_ Ord _tagCmp (Phone)] _N_
	 (<) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_,
	 (<=) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_,
	 (>=) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_,
	 (>) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_,
	 max = _A_ 2 _U_ 22 _N_ _S_ "EE" _N_ _N_,
	 min = _A_ 2 _U_ 22 _N_ _S_ "EE" _N_ _N_,
	 _tagCmp = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_ #-}
instance (Text a, Text b) => Text (BalBinSTree a b)
	{-# GHC_PRAGMA _M_ BalBinSTrees {-dfun-} _A_ 2 _U_ 22 _N_ _N_ _N_ _N_ #-}
instance Text a => Text (HmmTsL a)
	{-# GHC_PRAGMA _M_ HmmDigraphs {-dfun-} _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ #-}
instance Text Phone
	{-# GHC_PRAGMA _M_ Phones {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 5 _!_ _TUP_4 [(Int -> [Char] -> [(Phone, [Char])]), (Int -> Phone -> [Char] -> [Char]), ([Char] -> [([Phone], [Char])]), ([Phone] -> [Char] -> [Char])] [_CONSTM_ Text readsPrec (Phone), _CONSTM_ Text showsPrec (Phone), _CONSTM_ Text readList (Phone), _CONSTM_ Text showList (Phone)] _N_
	 readsPrec = _A_ 1 _U_ 12 _N_ _S_ "U(P)" {_A_ 1 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_,
	 showsPrec = _A_ 2 _U_ 112 _N_ _S_ "LE" _N_ _N_,
	 readList = _A_ 0 _U_ 2 _N_ _N_ _N_ _N_,
	 showList = _A_ 0 _U_ 12 _N_ _N_ _N_ _N_ #-}
instance Text a => Text (PrnNetwork a)
	{-# GHC_PRAGMA _M_ Pronunciations {-dfun-} _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ #-}

