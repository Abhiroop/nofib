{-# GHC_PRAGMA INTERFACE VERSION 5 #-}
interface HmmDigraphs where
import BalBinSTrees(BalBinSTree(..), bbstBuild, bbstDepth, bbstFlatten, bbstInsert, bbstInsertQuiet, bbstLookUp, bbstMember, bbstShowKeys)
import MaybeStateT(MST(..), bindMST, returnMST, thenMST)
import Phones(Phone(..), phone_bounds, phone_list)
import PreludeArray(Array, Assoc)
import PreludeStdIO(Maybe)
import Pronunciations(DictionaryEntry(..), Digraph(..), DigraphNode(..), PrnNetwork(..), Word(..), pre_hmm, readDictionary, readsPrnNetwork, showPrnNetwork)
data BalBinSTree a b 	{-# GHC_PRAGMA Nil | Node a b (BalBinSTree a b) (BalBinSTree a b) #-}
type DictionaryEntry a = ([Char], PrnNetwork a)
type Digraph a = [(a, [Int])]
type DigraphNode a = (a, [Int])
type HmmData = (Phone, Int)
type HmmNetworkDic = Array Phone (HmmTsL Int)
type HmmState = Int
data HmmTsA a   = HmmTsA [(Int, Float)] [(Int, Float)] (Array Int (a, [(Int, Float)]))
data HmmTsL a   = HmmTsL Int [(Int, Float)] [(Int, Float)] [(a, [(Int, Float)])]
type MST a b = a -> Maybe (b, a)
data Phone   = AA | AE | AH | AO | AW | AX | AXR | AY | EH | ER | EY | IH | IX | IY | OW | OY | UH | UW | L | EL | R | W | Y | M | N | EN | NG | F | TH | S | SH | HH | V | DH | Z | ZH | CH | JH | P | T | K | B | D | G | DX | SIL
data PrnNetwork a   = PrnN Int [Int] [Int] [(a, [Int])]
type ProbArc = (Int, Float)
type ProbDigraphA a = Array Int (a, [(Int, Float)])
type ProbDigraphL a = [(a, [(Int, Float)])]
type ProbDigraphNode a = (a, [(Int, Float)])
type Word = [Char]
bbstBuild :: Ord a => [(a, b)] -> BalBinSTree a b
	{-# GHC_PRAGMA _A_ 1 _U_ 21 _N_ _N_ _N_ _N_ #-}
bbstDepth :: BalBinSTree a b -> Int
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
bbstFlatten :: BalBinSTree a b -> [(a, b)]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
bbstInsert :: Ord a => BalBinSTree a b -> (a, b) -> BalBinSTree a b
	{-# GHC_PRAGMA _A_ 3 _U_ 221 _N_ _N_ _N_ _N_ #-}
bbstInsertQuiet :: Ord a => BalBinSTree a b -> (a, b) -> BalBinSTree a b
	{-# GHC_PRAGMA _A_ 3 _U_ 221 _N_ _N_ _N_ _N_ #-}
bbstLookUp :: (Ord a, Text a) => BalBinSTree a b -> a -> b
	{-# GHC_PRAGMA _A_ 2 _U_ 1122 _N_ _S_ "U(LSAALAAA)L" {_A_ 4 _U_ 122112 _N_ _N_ _N_ _N_} _N_ _N_ #-}
bbstMember :: Ord b => BalBinSTree b a -> b -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 212 _N_ _N_ _N_ _N_ #-}
bbstShowKeys :: Text a => Int -> BalBinSTree a b -> [Char]
	{-# GHC_PRAGMA _A_ 1 _U_ 111 _N_ _N_ _N_ _N_ #-}
bindMST :: (b -> Maybe (a, b)) -> (a -> b -> Maybe (c, b)) -> b -> Maybe (c, b)
	{-# GHC_PRAGMA _A_ 3 _U_ 112 _N_ _S_ "SLL" _N_ _N_ #-}
buildHmm :: Array Phone (HmmTsL Int) -> PrnNetwork (Phone, Int) -> HmmTsA (Phone, Int)
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LU(LLLL)" {_A_ 5 _U_ 22111 _N_ _N_ _N_ _N_} _N_ _N_ #-}
build_hmm_array :: [Assoc Phone (HmmTsL Int)] -> Array Phone (HmmTsL Int)
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _S_ "S" _N_ _N_ #-}
convert_to_log_probs :: HmmTsL a -> HmmTsL a
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(LLLL)" {_A_ 4 _U_ 2111 _N_ _N_ _N_ _N_} _N_ _N_ #-}
get_log_probs :: Ix a => Array a (HmmTsL b) -> Array a (HmmTsL b)
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _S_ "U(ASLA)L" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
returnMST :: b -> a -> Maybe (b, a)
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _N_ _N_ _N_ #-}
thenMST :: (b -> Maybe (a, b)) -> (a -> b -> Maybe (c, b)) -> b -> Maybe (c, b)
	{-# GHC_PRAGMA _A_ 3 _U_ 112 _N_ _S_ "SLL" _N_ _N_ #-}
phone_bounds :: (Phone, Phone)
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _N_ _N_ _N_ #-}
phone_list :: [Phone]
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 2 _APP_  _CONSTM_ Ix range (Phone) [ _ORIG_ Phones phone_bounds ] _N_ #-}
pre_hmm :: BalBinSTree [Char] (PrnNetwork Phone) -> [Char] -> PrnNetwork (Phone, Int)
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _N_ _N_ _N_ #-}
readDictionary :: [Char] -> [([Char], PrnNetwork Phone)]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
readHmms :: [Char] -> [Assoc Phone (HmmTsL Int)]
	{-# GHC_PRAGMA _A_ 0 _U_ 2 _N_ _N_ _N_ _N_ #-}
readsPrnNetwork :: Text a => [Char] -> Maybe (PrnNetwork a, [Char])
	{-# GHC_PRAGMA _A_ 0 _U_ 12 _N_ _N_ _N_ _SPECIALISE_ [ Phone ] 1 { _A_ 0 _U_ 2 _N_ _N_ _N_ _N_ } #-}
showPrnNetwork :: Text a => PrnNetwork a -> [Char]
	{-# GHC_PRAGMA _A_ 0 _U_ 11 _N_ _N_ _N_ _N_ #-}
instance Enum Phone
	{-# GHC_PRAGMA _M_ Phones {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 6 _!_ _TUP_5 [{{Ord Phone}}, (Phone -> [Phone]), (Phone -> Phone -> [Phone]), (Phone -> Phone -> [Phone]), (Phone -> Phone -> Phone -> [Phone])] [_DFUN_ Ord (Phone), _CONSTM_ Enum enumFrom (Phone), _CONSTM_ Enum enumFromThen (Phone), _CONSTM_ Enum enumFromTo (Phone), _CONSTM_ Enum enumFromThenTo (Phone)] _N_
	 enumFrom = _A_ 1 _U_ 1 _N_ _S_ "E" _N_ _N_,
	 enumFromThen = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_,
	 enumFromTo = _A_ 2 _U_ 22 _N_ _N_ _N_ _N_,
	 enumFromThenTo = _A_ 3 _U_ 222 _N_ _N_ _N_ _N_ #-}
instance Eq Phone
	{-# GHC_PRAGMA _M_ Phones {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Phone -> Phone -> Bool), (Phone -> Phone -> Bool)] [_CONSTM_ Eq (==) (Phone), _CONSTM_ Eq (/=) (Phone)] _N_
	 (==) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_,
	 (/=) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_ #-}
instance Ix Phone
	{-# GHC_PRAGMA _M_ Phones {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 5 _!_ _TUP_4 [{{Ord Phone}}, ((Phone, Phone) -> [Phone]), ((Phone, Phone) -> Phone -> Int), ((Phone, Phone) -> Phone -> Bool)] [_DFUN_ Ord (Phone), _CONSTM_ Ix range (Phone), _CONSTM_ Ix index (Phone), _CONSTM_ Ix inRange (Phone)] _N_
	 range = _A_ 1 _U_ 1 _N_ _S_ "U(EE)" {_A_ 2 _U_ 11 _N_ _N_ _N_ _N_} _N_ _N_,
	 index = _A_ 2 _U_ 12 _N_ _S_ "U(EE)E" {_A_ 3 _U_ 212 _N_ _N_ _N_ _N_} _N_ _N_,
	 inRange = _A_ 2 _U_ 11 _N_ _S_ "U(EE)E" {_A_ 3 _U_ 111 _N_ _N_ _N_ _N_} _N_ _N_ #-}
instance Ord Phone
	{-# GHC_PRAGMA _M_ Phones {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 9 _!_ _TUP_8 [{{Eq Phone}}, (Phone -> Phone -> Bool), (Phone -> Phone -> Bool), (Phone -> Phone -> Bool), (Phone -> Phone -> Bool), (Phone -> Phone -> Phone), (Phone -> Phone -> Phone), (Phone -> Phone -> _CMP_TAG)] [_DFUN_ Eq (Phone), _CONSTM_ Ord (<) (Phone), _CONSTM_ Ord (<=) (Phone), _CONSTM_ Ord (>=) (Phone), _CONSTM_ Ord (>) (Phone), _CONSTM_ Ord max (Phone), _CONSTM_ Ord min (Phone), _CONSTM_ Ord _tagCmp (Phone)] _N_
	 (<) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_,
	 (<=) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_,
	 (>=) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_,
	 (>) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_,
	 max = _A_ 2 _U_ 22 _N_ _S_ "EE" _N_ _N_,
	 min = _A_ 2 _U_ 22 _N_ _S_ "EE" _N_ _N_,
	 _tagCmp = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_ #-}
instance (Text a, Text b) => Text (BalBinSTree a b)
	{-# GHC_PRAGMA _M_ BalBinSTrees {-dfun-} _A_ 2 _U_ 22 _N_ _N_ _N_ _N_ #-}
instance Text a => Text (HmmTsL a)
	{-# GHC_PRAGMA _M_ HmmDigraphs {-dfun-} _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ #-}
instance Text Phone
	{-# GHC_PRAGMA _M_ Phones {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 5 _!_ _TUP_4 [(Int -> [Char] -> [(Phone, [Char])]), (Int -> Phone -> [Char] -> [Char]), ([Char] -> [([Phone], [Char])]), ([Phone] -> [Char] -> [Char])] [_CONSTM_ Text readsPrec (Phone), _CONSTM_ Text showsPrec (Phone), _CONSTM_ Text readList (Phone), _CONSTM_ Text showList (Phone)] _N_
	 readsPrec = _A_ 1 _U_ 12 _N_ _S_ "U(P)" {_A_ 1 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_,
	 showsPrec = _A_ 2 _U_ 112 _N_ _S_ "LE" _N_ _N_,
	 readList = _A_ 0 _U_ 2 _N_ _N_ _N_ _N_,
	 showList = _A_ 0 _U_ 12 _N_ _N_ _N_ _N_ #-}
instance Text a => Text (PrnNetwork a)
	{-# GHC_PRAGMA _M_ Pronunciations {-dfun-} _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ #-}

