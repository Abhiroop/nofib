{-# GHC_PRAGMA INTERFACE VERSION 5 #-}
interface BarakiConc3 where
import BaseDefs(ACMode, DExpr, Domain, Frontier, FrontierElem, Rep, Route)
bcApplyF0 :: (FrontierElem -> FrontierElem) -> [Domain] -> Rep -> Rep
	{-# GHC_PRAGMA _A_ 3 _U_ 221 _N_ _S_ "LLS" _N_ _N_ #-}
bcApplyF0_2 :: (FrontierElem -> FrontierElem) -> [Domain] -> Frontier -> Frontier
	{-# GHC_PRAGMA _A_ 3 _U_ 201 _N_ _S_ "LAU(LAL)" {_A_ 3 _U_ 221 _N_ _N_ _N_ _N_} _N_ _N_ #-}
bcClean :: DExpr -> DExpr
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
bcEApp :: [([Char], (Domain, Route, Route))] -> DExpr -> Route -> Route
	{-# GHC_PRAGMA _A_ 3 _U_ 221 _N_ _S_ "LSS" _N_ _N_ #-}
bcEApp_d :: [([Char], (Domain, Route, Route))] -> DExpr -> Domain
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ #-}
bcEdotF :: [([Char], (Domain, Route, Route))] -> DExpr -> Domain -> Rep -> Rep
	{-# GHC_PRAGMA _A_ 4 _U_ 2111 _N_ _S_ "LSSS" _N_ _N_ #-}
bcEdotFdotC :: [([Char], (Domain, Route, Route))] -> DExpr -> Domain -> Rep -> [DExpr] -> Route
	{-# GHC_PRAGMA _A_ 5 _U_ 21222 _N_ _S_ "LLSLL" _N_ _N_ #-}
bcFdotC :: [([Char], (Domain, Route, Route))] -> [DExpr] -> [Domain] -> Domain -> Rep -> Rep
	{-# GHC_PRAGMA _A_ 5 _U_ 22211 _N_ _S_ "LLLSS" _N_ _N_ #-}
bcGetD :: (c, a, b) -> c
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(SAA)" {_A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 3 1 X 1 _/\_ u0 u1 u2 -> \ (u3 :: u2) -> u3 _N_} _F_ _IF_ARGS_ 3 1 C 2 _/\_ u0 u1 u2 -> \ (u3 :: (u2, u0, u1)) -> case u3 of { _ALG_ _TUP_3 (u4 :: u2) (u5 :: u0) (u6 :: u1) -> u4; _NO_DEFLT_ } _N_ #-}
bcGetR :: (a, c, b) -> c
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(ASA)" {_A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 3 1 X 1 _/\_ u0 u1 u2 -> \ (u3 :: u2) -> u3 _N_} _F_ _IF_ARGS_ 3 1 C 2 _/\_ u0 u1 u2 -> \ (u3 :: (u0, u2, u1)) -> case u3 of { _ALG_ _TUP_3 (u4 :: u0) (u5 :: u2) (u6 :: u1) -> u5; _NO_DEFLT_ } _N_ #-}
bcGetT :: (a, b, c) -> c
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(AAS)" {_A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 3 1 X 1 _/\_ u0 u1 u2 -> \ (u3 :: u2) -> u3 _N_} _F_ _IF_ARGS_ 3 1 C 2 _/\_ u0 u1 u2 -> \ (u3 :: (u0, u1, u2)) -> case u3 of { _ALG_ _TUP_3 (u4 :: u0) (u5 :: u1) (u6 :: u2) -> u6; _NO_DEFLT_ } _N_ #-}
bcMakeInstance :: Bool -> Int -> ACMode -> DExpr -> [([Char], Domain)] -> Route -> Route
	{-# GHC_PRAGMA _A_ 6 _U_ 112222 _N_ _S_ "LLLSLL" _N_ _N_ #-}

