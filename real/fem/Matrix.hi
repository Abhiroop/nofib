{-# GHC_PRAGMA INTERFACE VERSION 3 #-}
interface Matrix where
import PreludeArray(Assoc)
import Vector(Vec)
data Mat a 	{-# GHC_PRAGMA MAT (Int, Int) (Vec a) #-}
boundmat :: Mat a -> (Int, Int)
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _S_ "U(U(LL)A)" {_A_ 2 _U_ 22 _N_ _F_ _IF_ARGS_ 1 2 XX 3 _/\_ u0 -> \ (u1 :: Int) (u2 :: Int) -> _!_ _TUP_2 [Int, Int] [u1, u2] _N_} _F_ _IF_ARGS_ 1 1 C 5 _/\_ u0 -> \ (u1 :: Mat u0) -> case u1 of { _ALG_ _ORIG_ Matrix MAT (u2 :: (Int, Int)) (u3 :: Vec u0) -> case u2 of { _ALG_ _TUP_2 (u4 :: Int) (u5 :: Int) -> _!_ _TUP_2 [Int, Int] [u4, u5]; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ #-}
col :: Mat a -> Int -> Vec a
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _N_ _N_ #-}
displaymat :: Text a => Mat a -> [Char]
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _N_ _N_ #-}
incrmat :: Num a => Mat a -> [Assoc (Int, Int) a] -> Mat a
	{-# GHC_PRAGMA _A_ 3 _U_ 211 _N_ _N_ _N_ #-}
intchcol :: Int -> Int -> Mat a -> Mat a
	{-# GHC_PRAGMA _A_ 3 _U_ 221 _S_ "LLU(U(LL)L)" {_A_ 5 _U_ 22222 _N_ _N_ _N_} _N_ _N_ #-}
intchrow :: Int -> Int -> Mat a -> Mat a
	{-# GHC_PRAGMA _A_ 3 _U_ 221 _S_ "LLU(U(LL)L)" {_A_ 5 _U_ 22222 _N_ _N_ _N_} _N_ _N_ #-}
interchmat :: (Int, Int) -> (Int, Int) -> Mat a -> Mat a
	{-# GHC_PRAGMA _A_ 3 _U_ 111 _S_ "U(LL)U(LL)U(U(LL)L)" {_A_ 7 _U_ 2222222 _N_ _N_ _N_} _N_ _N_ #-}
makemat :: (Int, Int) -> ((Int, Int) -> a) -> Mat a
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _S_ "U(LL)L" {_A_ 3 _U_ 222 _N_ _N_ _N_} _N_ _N_ #-}
matsub :: Mat a -> (Int, Int) -> a
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _S_ "U(U(AU(P))U(AU(U(U(P)U(P))P)))U(U(P)U(P))" {_A_ 6 _U_ 222222 _N_ _F_ _IF_ARGS_ 1 6 XXXXXX 8 _/\_ u0 -> \ (u1 :: Int#) (u2 :: Int#) (u3 :: Int#) (u4 :: Array# u0) (u5 :: Int#) (u6 :: Int#) -> case _#_ minusInt# [] [u5, 1#] of { _PRIM_ (u7 :: Int#) -> case _#_ timesInt# [] [u7, u1] of { _PRIM_ (u8 :: Int#) -> case _#_ plusInt# [] [u8, u6] of { _PRIM_ (u9 :: Int#) -> _APP_  _TYAPP_  _WRKR_ _ORIG_ Vector vecsub { u0 } [ u2, u3, u4, u9 ] } } } _N_} _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: Mat u0) (u2 :: (Int, Int)) -> case u1 of { _ALG_ _ORIG_ Matrix MAT (u3 :: (Int, Int)) (u4 :: Vec u0) -> case u3 of { _ALG_ _TUP_2 (u5 :: Int) (u6 :: Int) -> case u6 of { _ALG_ I# (u7 :: Int#) -> case u4 of { _ALG_ _ORIG_ Vector VEC (u8 :: Int) (u9 :: Array Int u0) -> case u9 of { _ALG_ _Array (ua :: (Int, Int)) (ub :: Array# u0) -> case ua of { _ALG_ _TUP_2 (uc :: Int) (ud :: Int) -> case uc of { _ALG_ I# (ue :: Int#) -> case ud of { _ALG_ I# (uf :: Int#) -> case u2 of { _ALG_ _TUP_2 (ug :: Int) (uh :: Int) -> case ug of { _ALG_ I# (ui :: Int#) -> case uh of { _ALG_ I# (uj :: Int#) -> case _#_ minusInt# [] [ui, 1#] of { _PRIM_ (uk :: Int#) -> case _#_ timesInt# [] [uk, u7] of { _PRIM_ (ul :: Int#) -> case _#_ plusInt# [] [ul, uj] of { _PRIM_ (um :: Int#) -> _APP_  _TYAPP_  _WRKR_ _ORIG_ Vector vecsub { u0 } [ ue, uf, ub, um ] } } }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ #-}
mmatmat :: Num a => Mat a -> Mat a -> Mat a
	{-# GHC_PRAGMA _A_ 1 _U_ 211 _N_ _N_ _N_ #-}
mmatvec :: Num a => Mat a -> Vec a -> Vec a
	{-# GHC_PRAGMA _A_ 1 _U_ 222 _N_ _N_ _N_ #-}
row :: Mat a -> Int -> Vec a
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _N_ _N_ #-}
updmat :: Mat a -> [Assoc (Int, Int) a] -> Mat a
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _N_ _N_ #-}

