{-# GHC_PRAGMA INTERFACE VERSION 3 #-}
interface Vector where
import PreludeArray(Array, Assoc)
data Vec a 	{-# GHC_PRAGMA VEC Int (Array Int a) #-}
boundvec :: Vec a -> Int
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _S_ "U(U(P)A)" {_A_ 1 _U_ 2 _N_ _F_ _IF_ARGS_ 1 1 X 2 _/\_ u0 -> \ (u1 :: Int#) -> _!_ I# [] [u1] _N_} _F_ _IF_ARGS_ 1 1 C 2 _/\_ u0 -> \ (u1 :: Vec u0) -> case u1 of { _ALG_ _ORIG_ Vector VEC (u2 :: Int) (u3 :: Array Int u0) -> u2; _NO_DEFLT_ } _N_ #-}
displayvec :: Text a => Vec a -> [Char]
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _N_ _N_ #-}
incrvec :: Num a => Vec a -> [Assoc Int a] -> Vec a
	{-# GHC_PRAGMA _A_ 3 _U_ 112 _S_ "LU(LL)L" {_A_ 4 _U_ 1222 _N_ _N_ _N_} _N_ _N_ #-}
makevec :: Int -> (Int -> a) -> Vec a
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _N_ _N_ #-}
maxupdvec :: (Num a, Ord a) => Vec a -> [Assoc Int a] -> Vec a
	{-# GHC_PRAGMA _A_ 4 _U_ 0112 _S_ "ALU(LL)L" {_A_ 4 _U_ 1222 _N_ _N_ _N_} _N_ _N_ #-}
updvec :: Vec a -> [Assoc Int a] -> Vec a
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _S_ "U(LL)L" {_A_ 3 _U_ 222 _N_ _N_ _N_} _N_ _N_ #-}
vecprod :: Num a => Vec a -> Vec a -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 222 _N_ _N_ _N_ #-}
vecsub :: Vec a -> Int -> a
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _S_ "U(AU(U(U(P)U(P))P))U(P)" {_A_ 4 _U_ 2222 _N_ _N_ _N_} _N_ _N_ #-}

