{-# GHC_PRAGMA INTERFACE VERSION 5 #-}
interface Vtslib where
import Core_datatype(Attribute(..), Attribute_Tag(..), Attribute_Value(..), Binary_conn(..), Binder_conn(..), Cnv_Fn(..), Constant_conn(..), Flagged_ITrm(..), IDec(..), ISgn(..), ITrm(..), Name'(..), Operand(..), Operator(..), Oprtype(..), Share_map(..), Tag(..), Tag_Arg(..), Tag_Arg_type(..), Thm(..), Trm(..), Unary_conn(..))
type Attribute = (Attribute_Tag, Attribute_Value)
data Attribute_Tag   = Name_Style | Symbol_Style | Pair_Style | Let_Style | Case_Style | Opr_Style | Fun_Style | Binder_Style | Constant_Style | Unary_Style | Binary_Style | Cond_Style | Recurse_Style | Hyp_Style | Dec_Style | Def_Style | Comment
data Attribute_Value   = Symbol_Name Name' | Datatype_Name [Name'] | Named | Indexed | Typed | Untyped | Let | Case | Prefixed | Linfixed | Rinfixed | Postfixed | Functional | Subscripted | Prefix_Binder | Infix_Binder | Recursive | Fn | NonDependent | Grouped | Ungrouped | Parameter | NonParameter | String' [Char]
data Binary_conn   = Or | And | Eq' | Issubtype
data Binder_conn   = Lambda | Forall | Exists | Pi | Sigma | Imp | Subtype | Delta | Choose
data Cnv_Fn   = Trm_Fn ([Tag_Arg] -> Trm) | Thm_Fn ([Tag_Arg] -> Thm)
data Constant_conn   = T | F | Bool' | Univ Int
data Flagged_ITrm   = Opr Operator Oprtype Int | Opnd Operand | Prs_Err [Char]
data IDec   = Symbol_dec ITrm [(Attribute_Tag, Attribute_Value)] | Axiom_dec ITrm [(Attribute_Tag, Attribute_Value)] | Def ITrm ITrm [(Attribute_Tag, Attribute_Value)] | Data [IDec] [[ITrm]] [(Attribute_Tag, Attribute_Value)] | Decpair IDec IDec [(Attribute_Tag, Attribute_Value)]
data ISgn   = Empty [(Attribute_Tag, Attribute_Value)] | Extend IDec ISgn [(Attribute_Tag, Attribute_Value)] | Combine ISgn ISgn Int [Int] [(Attribute_Tag, Attribute_Value)] | Share ISgn Int Int Int [Int] [(Attribute_Tag, Attribute_Value)]
data ITrm   = Sym Int Int [ITrm] [(Attribute_Tag, Attribute_Value)] | App ITrm ITrm [ITrm] [(Attribute_Tag, Attribute_Value)] | Pair ITrm ITrm ITrm [ITrm] [(Attribute_Tag, Attribute_Value)] | Binder Binder_conn IDec ITrm [ITrm] [(Attribute_Tag, Attribute_Value)] | Constant Constant_conn [ITrm] [(Attribute_Tag, Attribute_Value)] | Unary Unary_conn ITrm [ITrm] [(Attribute_Tag, Attribute_Value)] | Binary' Binary_conn ITrm ITrm [ITrm] [(Attribute_Tag, Attribute_Value)] | Cond IDec ITrm ITrm [ITrm] [(Attribute_Tag, Attribute_Value)] | Const Int Int Int [ITrm] [(Attribute_Tag, Attribute_Value)] | Recurse [ITrm] ITrm [ITrm] [(Attribute_Tag, Attribute_Value)] | Tagid ([Char], [Tag_Arg_type], [Cnv_Fn]) [Tag_Arg] | ITrm_Err [Char]
data Name'   = Name [Char] | Operator' [Char] Int Oprtype
data Operand   = Itrm ITrm | Idec IDec | Isgn ISgn | PApp Binder_conn IDec Bool | PairApp ITrm | ParIfx Binary_conn ITrm | TypApp Flagged_ITrm | ParColon ITrm
data Operator   = OpItrm ITrm | OpBdr Binder_conn | OpIfx Binary_conn | Spl [Char]
data Oprtype   = Pre | Post | BinL | BinR
data Option a   = NONE | SOME a
type Share_map = [Int]
data Sum a b   = Inl a | Inr b
type Tag = ([Char], [Tag_Arg_type], [Cnv_Fn])
data Tag_Arg   = Tg_Trm Trm | Tg_Thm Thm | Tg_Int [Int]
data Tag_Arg_type   = Term_Arg | Deriv_Arg | Int_Arg
data Thm   = TH ITrm ISgn | TH_Err [Char]
data Trm   = TM ITrm ITrm ISgn | TM_Err [Char]
data Unary_conn   = Not
assoc :: Eq a => a -> [(a, b)] -> Option b
	{-# GHC_PRAGMA _A_ 1 _U_ 121 _N_ _N_ _N_ _N_ #-}
curry :: ((a, b) -> c) -> a -> b -> c
	{-# GHC_PRAGMA _A_ 3 _U_ 122 _N_ _S_ "SLL" _F_ _IF_ARGS_ 3 3 XXX 6 _/\_ u0 u1 u2 -> \ (u3 :: (u0, u1) -> u2) (u4 :: u0) (u5 :: u1) -> let {(u6 :: (u0, u1)) = _!_ _TUP_2 [u0, u1] [u4, u5]} in _APP_  u3 [ u6 ] _N_ #-}
exists :: (a -> Bool) -> [a] -> Bool
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ #-}
for :: Int -> (a -> a) -> a -> a
	{-# GHC_PRAGMA _A_ 3 _U_ 122 _N_ _S_ "U(P)LL" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
forall :: (a -> Bool) -> [a] -> Bool
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ #-}
haskey :: Eq a => a -> [(a, b)] -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 121 _N_ _N_ _N_ _N_ #-}
map' :: (Int -> a -> b) -> [a] -> [b]
	{-# GHC_PRAGMA _A_ 1 _U_ 21 _N_ _N_ _N_ _N_ #-}
uncurry :: (a -> b -> c) -> (a, b) -> c
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "SU(LL)" {_A_ 3 _U_ 122 _N_ _N_ _F_ _IF_ARGS_ 3 3 XXX 3 _/\_ u0 u1 u2 -> \ (u3 :: u0 -> u1 -> u2) (u4 :: u0) (u5 :: u1) -> _APP_  u3 [ u4, u5 ] _N_} _F_ _IF_ARGS_ 3 2 XC 4 _/\_ u0 u1 u2 -> \ (u3 :: u0 -> u1 -> u2) (u4 :: (u0, u1)) -> case u4 of { _ALG_ _TUP_2 (u5 :: u0) (u6 :: u1) -> _APP_  u3 [ u5, u6 ]; _NO_DEFLT_ } _N_ #-}
instance Eq Attribute_Tag
	{-# GHC_PRAGMA _M_ Core_datatype {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Attribute_Tag -> Attribute_Tag -> Bool), (Attribute_Tag -> Attribute_Tag -> Bool)] [_CONSTM_ Eq (==) (Attribute_Tag), _CONSTM_ Eq (/=) (Attribute_Tag)] _N_
	 (==) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_,
	 (/=) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_ #-}
instance Eq Attribute_Value
	{-# GHC_PRAGMA _M_ Core_datatype {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Attribute_Value -> Attribute_Value -> Bool), (Attribute_Value -> Attribute_Value -> Bool)] [_CONSTM_ Eq (==) (Attribute_Value), _CONSTM_ Eq (/=) (Attribute_Value)] _N_
	 (==) = _A_ 2 _U_ 22 _N_ _S_ "SS" _N_ _N_,
	 (/=) = _A_ 2 _U_ 22 _N_ _S_ "SS" _N_ _N_ #-}
instance Eq Binary_conn
	{-# GHC_PRAGMA _M_ Core_datatype {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Binary_conn -> Binary_conn -> Bool), (Binary_conn -> Binary_conn -> Bool)] [_CONSTM_ Eq (==) (Binary_conn), _CONSTM_ Eq (/=) (Binary_conn)] _N_
	 (==) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_,
	 (/=) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_ #-}
instance Eq Binder_conn
	{-# GHC_PRAGMA _M_ Core_datatype {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Binder_conn -> Binder_conn -> Bool), (Binder_conn -> Binder_conn -> Bool)] [_CONSTM_ Eq (==) (Binder_conn), _CONSTM_ Eq (/=) (Binder_conn)] _N_
	 (==) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_,
	 (/=) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_ #-}
instance Eq Constant_conn
	{-# GHC_PRAGMA _M_ Core_datatype {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Constant_conn -> Constant_conn -> Bool), (Constant_conn -> Constant_conn -> Bool)] [_CONSTM_ Eq (==) (Constant_conn), _CONSTM_ Eq (/=) (Constant_conn)] _N_
	 (==) = _A_ 2 _U_ 22 _N_ _S_ "SS" _N_ _N_,
	 (/=) = _A_ 2 _U_ 22 _N_ _S_ "SS" _N_ _N_ #-}
instance Eq Name'
	{-# GHC_PRAGMA _M_ Core_datatype {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Name' -> Name' -> Bool), (Name' -> Name' -> Bool)] [_CONSTM_ Eq (==) (Name'), _CONSTM_ Eq (/=) (Name')] _N_
	 (==) = _A_ 2 _U_ 11 _N_ _S_ "SS" _N_ _N_,
	 (/=) = _A_ 2 _U_ 11 _N_ _S_ "SS" _N_ _N_ #-}
instance Eq Oprtype
	{-# GHC_PRAGMA _M_ Core_datatype {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Oprtype -> Oprtype -> Bool), (Oprtype -> Oprtype -> Bool)] [_CONSTM_ Eq (==) (Oprtype), _CONSTM_ Eq (/=) (Oprtype)] _N_
	 (==) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_,
	 (/=) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_ #-}
instance Eq Tag_Arg_type
	{-# GHC_PRAGMA _M_ Core_datatype {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Tag_Arg_type -> Tag_Arg_type -> Bool), (Tag_Arg_type -> Tag_Arg_type -> Bool)] [_CONSTM_ Eq (==) (Tag_Arg_type), _CONSTM_ Eq (/=) (Tag_Arg_type)] _N_
	 (==) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_,
	 (/=) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_ #-}
instance Eq Unary_conn
	{-# GHC_PRAGMA _M_ Core_datatype {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Unary_conn -> Unary_conn -> Bool), (Unary_conn -> Unary_conn -> Bool)] [_CONSTM_ Eq (==) (Unary_conn), _CONSTM_ Eq (/=) (Unary_conn)] _N_
	 (==) = _A_ 2 _U_ 11 _N_ _S_ "EE" _F_ _IF_ARGS_ 0 2 CC 3 \ (u0 :: Unary_conn) (u1 :: Unary_conn) -> case u0 of { _ALG_ _ORIG_ Core_datatype Not  -> case u1 of { _ALG_ _ORIG_ Core_datatype Not  -> _!_ True [] []; _NO_DEFLT_ }; _NO_DEFLT_ } _N_,
	 (/=) = _A_ 2 _U_ 11 _N_ _S_ "EE" _F_ _IF_ARGS_ 0 2 CC 3 \ (u0 :: Unary_conn) (u1 :: Unary_conn) -> case u0 of { _ALG_ _ORIG_ Core_datatype Not  -> case u1 of { _ALG_ _ORIG_ Core_datatype Not  -> _!_ False [] []; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ #-}

