{-# GHC_PRAGMA INTERFACE VERSION 5 #-}
interface Core_datatype where
type Attribute = (Attribute_Tag, Attribute_Value)
data Attribute_Tag   = Name_Style | Symbol_Style | Pair_Style | Let_Style | Case_Style | Opr_Style | Fun_Style | Binder_Style | Constant_Style | Unary_Style | Binary_Style | Cond_Style | Recurse_Style | Hyp_Style | Dec_Style | Def_Style | Comment
data Attribute_Value   = Symbol_Name Name' | Datatype_Name [Name'] | Named | Indexed | Typed | Untyped | Let | Case | Prefixed | Linfixed | Rinfixed | Postfixed | Functional | Subscripted | Prefix_Binder | Infix_Binder | Recursive | Fn | NonDependent | Grouped | Ungrouped | Parameter | NonParameter | String' [Char]
data Binary_conn   = Or | And | Eq' | Issubtype
data Binder_conn   = Lambda | Forall | Exists | Pi | Sigma | Imp | Subtype | Delta | Choose
data Cnv_Fn   = Trm_Fn ([Tag_Arg] -> Trm) | Thm_Fn ([Tag_Arg] -> Thm)
data Constant_conn   = T | F | Bool' | Univ Int
data Flagged_ITrm   = Opr Operator Oprtype Int | Opnd Operand | Prs_Err [Char]
data IDec   = Symbol_dec ITrm [(Attribute_Tag, Attribute_Value)] | Axiom_dec ITrm [(Attribute_Tag, Attribute_Value)] | Def ITrm ITrm [(Attribute_Tag, Attribute_Value)] | Data [IDec] [[ITrm]] [(Attribute_Tag, Attribute_Value)] | Decpair IDec IDec [(Attribute_Tag, Attribute_Value)]
data ISgn   = Empty [(Attribute_Tag, Attribute_Value)] | Extend IDec ISgn [(Attribute_Tag, Attribute_Value)] | Combine ISgn ISgn Int [Int] [(Attribute_Tag, Attribute_Value)] | Share ISgn Int Int Int [Int] [(Attribute_Tag, Attribute_Value)]
data ITrm   = Sym Int Int [ITrm] [(Attribute_Tag, Attribute_Value)] | App ITrm ITrm [ITrm] [(Attribute_Tag, Attribute_Value)] | Pair ITrm ITrm ITrm [ITrm] [(Attribute_Tag, Attribute_Value)] | Binder Binder_conn IDec ITrm [ITrm] [(Attribute_Tag, Attribute_Value)] | Constant Constant_conn [ITrm] [(Attribute_Tag, Attribute_Value)] | Unary Unary_conn ITrm [ITrm] [(Attribute_Tag, Attribute_Value)] | Binary' Binary_conn ITrm ITrm [ITrm] [(Attribute_Tag, Attribute_Value)] | Cond IDec ITrm ITrm [ITrm] [(Attribute_Tag, Attribute_Value)] | Const Int Int Int [ITrm] [(Attribute_Tag, Attribute_Value)] | Recurse [ITrm] ITrm [ITrm] [(Attribute_Tag, Attribute_Value)] | Tagid ([Char], [Tag_Arg_type], [Cnv_Fn]) [Tag_Arg] | ITrm_Err [Char]
data Name'   = Name [Char] | Operator' [Char] Int Oprtype
data Operand   = Itrm ITrm | Idec IDec | Isgn ISgn | PApp Binder_conn IDec Bool | PairApp ITrm | ParIfx Binary_conn ITrm | TypApp Flagged_ITrm | ParColon ITrm
data Operator   = OpItrm ITrm | OpBdr Binder_conn | OpIfx Binary_conn | Spl [Char]
data Oprtype   = Pre | Post | BinL | BinR
type Share_map = [Int]
type Tag = ([Char], [Tag_Arg_type], [Cnv_Fn])
data Tag_Arg   = Tg_Trm Trm | Tg_Thm Thm | Tg_Int [Int]
data Tag_Arg_type   = Term_Arg | Deriv_Arg | Int_Arg
data Thm   = TH ITrm ISgn | TH_Err [Char]
data Trm   = TM ITrm ITrm ISgn | TM_Err [Char]
data Unary_conn   = Not
instance Eq Attribute_Tag
	{-# GHC_PRAGMA _M_ Core_datatype {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Attribute_Tag -> Attribute_Tag -> Bool), (Attribute_Tag -> Attribute_Tag -> Bool)] [_CONSTM_ Eq (==) (Attribute_Tag), _CONSTM_ Eq (/=) (Attribute_Tag)] _N_
	 (==) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_,
	 (/=) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_ #-}
instance Eq Attribute_Value
	{-# GHC_PRAGMA _M_ Core_datatype {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Attribute_Value -> Attribute_Value -> Bool), (Attribute_Value -> Attribute_Value -> Bool)] [_CONSTM_ Eq (==) (Attribute_Value), _CONSTM_ Eq (/=) (Attribute_Value)] _N_
	 (==) = _A_ 2 _U_ 22 _N_ _S_ "SS" _N_ _N_,
	 (/=) = _A_ 2 _U_ 22 _N_ _S_ "SS" _N_ _N_ #-}
instance Eq Binary_conn
	{-# GHC_PRAGMA _M_ Core_datatype {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Binary_conn -> Binary_conn -> Bool), (Binary_conn -> Binary_conn -> Bool)] [_CONSTM_ Eq (==) (Binary_conn), _CONSTM_ Eq (/=) (Binary_conn)] _N_
	 (==) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_,
	 (/=) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_ #-}
instance Eq Binder_conn
	{-# GHC_PRAGMA _M_ Core_datatype {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Binder_conn -> Binder_conn -> Bool), (Binder_conn -> Binder_conn -> Bool)] [_CONSTM_ Eq (==) (Binder_conn), _CONSTM_ Eq (/=) (Binder_conn)] _N_
	 (==) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_,
	 (/=) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_ #-}
instance Eq Constant_conn
	{-# GHC_PRAGMA _M_ Core_datatype {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Constant_conn -> Constant_conn -> Bool), (Constant_conn -> Constant_conn -> Bool)] [_CONSTM_ Eq (==) (Constant_conn), _CONSTM_ Eq (/=) (Constant_conn)] _N_
	 (==) = _A_ 2 _U_ 22 _N_ _S_ "SS" _N_ _N_,
	 (/=) = _A_ 2 _U_ 22 _N_ _S_ "SS" _N_ _N_ #-}
instance Eq Name'
	{-# GHC_PRAGMA _M_ Core_datatype {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Name' -> Name' -> Bool), (Name' -> Name' -> Bool)] [_CONSTM_ Eq (==) (Name'), _CONSTM_ Eq (/=) (Name')] _N_
	 (==) = _A_ 2 _U_ 11 _N_ _S_ "SS" _N_ _N_,
	 (/=) = _A_ 2 _U_ 11 _N_ _S_ "SS" _N_ _N_ #-}
instance Eq Oprtype
	{-# GHC_PRAGMA _M_ Core_datatype {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Oprtype -> Oprtype -> Bool), (Oprtype -> Oprtype -> Bool)] [_CONSTM_ Eq (==) (Oprtype), _CONSTM_ Eq (/=) (Oprtype)] _N_
	 (==) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_,
	 (/=) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_ #-}
instance Eq Tag_Arg_type
	{-# GHC_PRAGMA _M_ Core_datatype {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Tag_Arg_type -> Tag_Arg_type -> Bool), (Tag_Arg_type -> Tag_Arg_type -> Bool)] [_CONSTM_ Eq (==) (Tag_Arg_type), _CONSTM_ Eq (/=) (Tag_Arg_type)] _N_
	 (==) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_,
	 (/=) = _A_ 2 _U_ 11 _N_ _S_ "EE" _N_ _N_ #-}
instance Eq Unary_conn
	{-# GHC_PRAGMA _M_ Core_datatype {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Unary_conn -> Unary_conn -> Bool), (Unary_conn -> Unary_conn -> Bool)] [_CONSTM_ Eq (==) (Unary_conn), _CONSTM_ Eq (/=) (Unary_conn)] _N_
	 (==) = _A_ 2 _U_ 11 _N_ _S_ "EE" _F_ _IF_ARGS_ 0 2 CC 3 \ (u0 :: Unary_conn) (u1 :: Unary_conn) -> case u0 of { _ALG_ _ORIG_ Core_datatype Not  -> case u1 of { _ALG_ _ORIG_ Core_datatype Not  -> _!_ True [] []; _NO_DEFLT_ }; _NO_DEFLT_ } _N_,
	 (/=) = _A_ 2 _U_ 11 _N_ _S_ "EE" _F_ _IF_ARGS_ 0 2 CC 3 \ (u0 :: Unary_conn) (u1 :: Unary_conn) -> case u0 of { _ALG_ _ORIG_ Core_datatype Not  -> case u1 of { _ALG_ _ORIG_ Core_datatype Not  -> _!_ False [] []; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ #-}

