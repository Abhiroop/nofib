{-# GHC_PRAGMA INTERFACE VERSION 5 #-}
interface Display where
import Goals(GOAL, Obj)
import Kernel(Sgn)
import Tree(TREE, Tree_state)
import Type_defs(Maybe)
import Vtslib(Option)
import X_interface(Form_input)
edit_comment :: Tree_state GOAL a b -> ([Char], [Int], [Int]) -> (([Char], [Int], [Int]), Maybe (Tree_state GOAL a b) [Char], [Char])
	{-# GHC_PRAGMA _A_ 1 _U_ 12 _N_ _S_ "U(LLL)" {_A_ 3 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
get_comment :: TREE GOAL a b -> [Char]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(U(AASAAAAA)AAAA)" {_A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 2 1 C 4 _/\_ u0 u1 -> \ (u2 :: Option [Char]) -> case u2 of { _ALG_ _ORIG_ Vtslib NONE  -> _!_ _NIL_ [Char] []; _ORIG_ Vtslib SOME (u3 :: [Char]) -> u3; _NO_DEFLT_ } _N_} _F_ _ALWAYS_ _/\_ u0 u1 -> \ (u2 :: TREE GOAL u0 u1) -> case u2 of { _ALG_ _ORIG_ Tree Tree (u3 :: GOAL) (u4 :: [TREE GOAL u0 u1]) (u5 :: Option u0) (u6 :: u1 -> TREE GOAL u0 u1 -> TREE GOAL u0 u1) (u7 :: Option (TREE GOAL u0 u1)) -> case u3 of { _ALG_ _ORIG_ Goals Goal (u8 :: Option [Char]) (u9 :: Option [[Char]]) (ua :: Option [Char]) (ub :: [Char]) (uc :: Obj) (ud :: Bool) (ue :: Sgn) (uf :: [[([Char], Option (Sum (Int, Bool) (Int, Int, [(Int, Int)]), (Int, [Char])))]]) -> case ua of { _ALG_ _ORIG_ Vtslib NONE  -> _!_ _NIL_ [Char] []; _ORIG_ Vtslib SOME (ug :: [Char]) -> ug; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ #-}
make_form :: Option [Char] -> Option [Char] -> Option [Char] -> Option [Char] -> [Form_input]
	{-# GHC_PRAGMA _A_ 4 _U_ 1111 _N_ _N_ _N_ _N_ #-}
own_win :: [Char] -> [Char] -> ([Char], [Int], [Int]) -> (([Char], [Int], [Int]), [Char])
	{-# GHC_PRAGMA _A_ 3 _U_ 222 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _ORIG_ X_interface x_display _N_ #-}
scratch_win :: [Char] -> [Char] -> ([Char], [Int], [Int]) -> (([Char], [Int], [Int]), [Char])
	{-# GHC_PRAGMA _A_ 2 _U_ 122 _N_ _N_ _N_ _N_ #-}
select :: Eq a => a -> [a] -> Int
	{-# GHC_PRAGMA _A_ 1 _U_ 121 _N_ _N_ _N_ _SPECIALISE_ [ [Char] ] 1 { _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ } #-}
set_comment :: [Char] -> TREE GOAL a b -> TREE GOAL a b
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "SU(U(LLALLLLL)LLLL)" _N_ _N_ #-}
show_Trm :: Sgn -> a -> b -> c -> [Char] -> [Char]
	{-# GHC_PRAGMA _A_ 5 _U_ 20002 _N_ _S_ "LAAAL" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _F_ _IF_ARGS_ 3 5 XXXXX 7 _/\_ u0 u1 u2 -> \ (u3 :: Sgn) (u4 :: u0) (u5 :: u1) (u6 :: u2) (u7 :: [Char]) -> let {(u8 :: Trm) = _APP_  _WRKR_ _ORIG_ Parse parse_tm [ _ORIG_ Tags tgL, u3, u7 ]} in _APP_  _TYAPP_  _TYAPP_  _WRKR_ _ORIG_ Unparse unparse_Trm { Sgn } { u2 } [ u8 ] _N_ #-}
show_args :: TREE GOAL a b -> ([Char], [Int], [Int]) -> (([Char], [Int], [Int]), [Char])
	{-# GHC_PRAGMA _A_ 1 _U_ 12 _N_ _S_ "U(U(SLALAAAA)AAAA)" {_A_ 3 _U_ 1112 _N_ _N_ _N_ _N_} _N_ _N_ #-}
show_arguments :: Tree_state GOAL a b -> ([Char], [Int], [Int]) -> (([Char], [Int], [Int]), Maybe (Tree_state GOAL a b) c, [Char])
	{-# GHC_PRAGMA _A_ 1 _U_ 12 _N_ _S_ "U(LLL)" {_A_ 3 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
show_com :: TREE GOAL a b -> ([Char], [Int], [Int]) -> (([Char], [Int], [Int]), Maybe (TREE GOAL a b) c, [Char])
	{-# GHC_PRAGMA _A_ 0 _U_ 22 _N_ _N_ _N_ _N_ #-}
show_comment :: Tree_state GOAL a b -> ([Char], [Int], [Int]) -> (([Char], [Int], [Int]), Maybe (Tree_state GOAL a b) c, [Char])
	{-# GHC_PRAGMA _A_ 1 _U_ 12 _N_ _S_ "U(U(U(LLSLLLLL)LLLL)LL)" {_A_ 3 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
show_error :: a -> [Char]
	{-# GHC_PRAGMA _A_ 1 _U_ 0 _N_ _S_ "A" {_A_ 0 _N_ _N_ _N_ _N_ _N_} _F_ _IF_ARGS_ 1 1 X 4 _/\_ u0 -> \ (u1 :: u0) -> _NOREP_S_ "Bad Object" _N_ #-}
show_goal_cmd :: Tree_state GOAL a (b, c, d) -> ([Char], [Int], [Int]) -> (([Char], [Int], [Int]), Maybe (Tree_state GOAL a (b, c, d)) e, [Char])
	{-# GHC_PRAGMA _A_ 1 _U_ 12 _N_ _S_ "U(LLL)" {_A_ 3 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
show_obj :: Sgn -> a -> b -> c -> Option [Char] -> Option [Char] -> Option [Char] -> Option [Char] -> ([Char], [Int], [Int]) -> (([Char], [Int], [Int]), Maybe [Char] [Char], [Char])
	{-# GHC_PRAGMA _A_ 8 _U_ 200011112 _N_ _S_ "LAAALLLL" {_A_ 5 _U_ 211112 _N_ _N_ _N_ _N_} _N_ _N_ #-}
show_object :: Tree_state GOAL a (b, c, d) -> ([Char], [Int], [Int]) -> (([Char], [Int], [Int]), Maybe (Tree_state GOAL a (b, c, d)) [Char], [Char])
	{-# GHC_PRAGMA _A_ 0 _U_ 22 _N_ _N_ _N_ _N_ #-}
show_subgoal_cmd :: Int -> Tree_state GOAL a (b, c, d) -> ([Char], [Int], [Int]) -> (([Char], [Int], [Int]), Maybe (Tree_state GOAL a (b, c, d)) e, [Char])
	{-# GHC_PRAGMA _A_ 2 _U_ 112 _N_ _S_ "LU(U(LLLLL)LL)" {_A_ 4 _U_ 12222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
show_tactics :: a -> ([Char], [Int], [Int]) -> (([Char], [Int], [Int]), Maybe a b, [Char])
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _N_ _N_ _N_ #-}
show_theory :: Tree_state GOAL a (b, c, d) -> ([Char], [Int], [Int]) -> (([Char], [Int], [Int]), Maybe (Tree_state GOAL a (b, c, d)) [Char], [Char])
	{-# GHC_PRAGMA _A_ 0 _U_ 22 _N_ _N_ _N_ _N_ #-}
show_theory' :: a -> (Sgn -> [Char]) -> GOAL -> ([Char], [Int], [Int]) -> (([Char], [Int], [Int]), Maybe a b, [Char])
	{-# GHC_PRAGMA _A_ 0 _U_ 2112 _N_ _N_ _N_ _N_ #-}
split_line :: [Char] -> [[Char]]
	{-# GHC_PRAGMA _A_ 0 _U_ 1 _N_ _N_ _N_ _N_ #-}
theory_form :: [Form_input]
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _N_ _N_ _N_ #-}
typeL :: [[Char]]
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _N_ _N_ _N_ #-}
unparse_obj :: Sgn -> (a, b, c) -> Obj -> [Char]
	{-# GHC_PRAGMA _A_ 3 _U_ 201 _N_ _S_ "LAS" {_A_ 2 _U_ 21 _N_ _N_ _N_ _N_} _N_ _N_ #-}
wins :: [[Char]]
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _N_ _N_ _N_ #-}

