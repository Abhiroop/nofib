{-# GHC_PRAGMA INTERFACE VERSION 5 #-}
interface Sub_Core4 where
import Core_datatype(Attribute_Tag, Attribute_Value, IDec, ISgn, ITrm)
import Vtslib(Option)
add_type :: ITrm -> ITrm -> ITrm
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _S_ "SL" _N_ _N_ #-}
addequiv :: Ord a => (Int, Int) -> [a] -> [a]
	{-# GHC_PRAGMA _A_ 1 _U_ 212 _N_ _N_ _N_ _N_ #-}
addequivL :: (Ord b, Num a) => Int -> Int -> a -> [b] -> [b]
	{-# GHC_PRAGMA _A_ 2 _U_ 212222 _N_ _S_ "LU(U(SA)AALAAAAAL)" {_A_ 4 _U_ 22222222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
canonical :: Int -> [a] -> a
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _S_ "U(P)S" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
clause_types :: ISgn -> ITrm -> ITrm -> ([ITrm], [Int])
	{-# GHC_PRAGMA _A_ 3 _U_ 222 _N_ _N_ _N_ _N_ #-}
equiv :: Eq a => a -> [a] -> [Int]
	{-# GHC_PRAGMA _A_ 3 _U_ 121 _N_ _S_ "LLS" _N_ _N_ #-}
eta_match :: a -> b -> c -> d
	{-# GHC_PRAGMA _A_ 3 _U_ 000 _N_ _S_ _!_ _F_ _IF_ARGS_ 4 3 XXX 2 _/\_ u0 u1 u2 u3 -> \ (u4 :: u0) (u5 :: u1) (u6 :: u2) -> _APP_  _TYAPP_  error { u3 } [ _NOREP_S_ "VTS_ERROR" ] _N_ #-}
gen_type :: Int -> ITrm -> [ITrm] -> ITrm -> [ITrm] -> ITrm
	{-# GHC_PRAGMA _A_ 5 _U_ 22121 _N_ _S_ "LSLLS" _N_ _N_ #-}
gen_typeL :: [ITrm] -> ITrm -> ITrm -> [[ITrm]] -> Int -> Int -> Int -> [ITrm]
	{-# GHC_PRAGMA _A_ 7 _U_ 2221222 _N_ _S_ "LLLSLLL" _N_ _N_ #-}
get_datatype_info :: ISgn -> ITrm -> (Int, Int, [ITrm], [IDec], [[ITrm]])
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ #-}
get_dec_att :: IDec -> [(Attribute_Tag, Attribute_Value)]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
get_sgn_att :: ISgn -> [(Attribute_Tag, Attribute_Value)]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _IF_ARGS_ 0 1 C 8 \ (u0 :: ISgn) -> case u0 of { _ALG_ _ORIG_ Core_datatype Empty (u1 :: [(Attribute_Tag, Attribute_Value)]) -> u1; _ORIG_ Core_datatype Extend (u2 :: IDec) (u3 :: ISgn) (u4 :: [(Attribute_Tag, Attribute_Value)]) -> u4; _ORIG_ Core_datatype Combine (u5 :: ISgn) (u6 :: ISgn) (u7 :: Int) (u8 :: [Int]) (u9 :: [(Attribute_Tag, Attribute_Value)]) -> u9; _ORIG_ Core_datatype Share (ua :: ISgn) (ub :: Int) (uc :: Int) (ud :: Int) (ue :: [Int]) (uf :: [(Attribute_Tag, Attribute_Value)]) -> uf; _NO_DEFLT_ } _N_ #-}
ind_type :: Int -> ITrm -> [ITrm] -> ITrm -> [ITrm] -> ITrm
	{-# GHC_PRAGMA _A_ 5 _U_ 22121 _N_ _S_ "LLLLS" _N_ _N_ #-}
ind_typeL :: ITrm -> [ITrm] -> ITrm -> [[ITrm]] -> Int -> Int -> Int -> [ITrm]
	{-# GHC_PRAGMA _A_ 7 _U_ 2221222 _N_ _S_ "LLLSLLL" _N_ _N_ #-}
induction_trm :: ISgn -> ITrm -> ITrm
	{-# GHC_PRAGMA _A_ 0 _U_ 22 _N_ _N_ _N_ _N_ #-}
is_sub_sgn :: ISgn -> ISgn -> Option Int
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _S_ "SS" _N_ _N_ #-}
make_ind :: ITrm -> ITrm -> [ITrm] -> ITrm
	{-# GHC_PRAGMA _A_ 3 _U_ 221 _N_ _S_ "LLS" _N_ _N_ #-}
make_rec :: ITrm -> ITrm -> [ITrm] -> ITrm
	{-# GHC_PRAGMA _A_ 3 _U_ 221 _N_ _S_ "LLS" _N_ _N_ #-}
no_params :: [ITrm] -> Int
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
set_dec_att :: IDec -> [(Attribute_Tag, Attribute_Value)] -> IDec
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _S_ "SL" _N_ _N_ #-}
set_sgn_att :: ISgn -> [(Attribute_Tag, Attribute_Value)] -> ISgn
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _S_ "SL" _N_ _N_ #-}
shift :: Int -> Int -> ITrm -> ITrm
	{-# GHC_PRAGMA _A_ 3 _U_ 122 _N_ _S_ "U(P)LL" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
split_def :: IDec -> (IDec, ITrm, ITrm)
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
union :: Eq a => [a] -> [a] -> [a]
	{-# GHC_PRAGMA _A_ 1 _U_ 112 _N_ _N_ _N_ _SPECIALISE_ [ Int ] 1 { _A_ 2 _U_ 12 _N_ _S_ "SS" _N_ _N_ } #-}
update :: a -> [Int] -> [a] -> [a]
	{-# GHC_PRAGMA _A_ 3 _U_ 221 _N_ _S_ "LLS" _N_ _N_ #-}

